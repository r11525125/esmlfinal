// =============================================================================
// Generated by efx_ipmgr
// Version: 2023.1.150
// IP Version: 5.0
// =============================================================================

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2023 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//                                                                       
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//                                                                       
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.                                                
//
////////////////////////////////////////////////////////////////////////////////

`define IP_UUID _3c48db7e8f7a4061b4268f003b844934
`define IP_NAME_CONCAT(a,b) a``b
`define IP_MODULE_NAME(name) `IP_NAME_CONCAT(name,`IP_UUID)
module tse_mac_rgmii (
input mac_reset,
input proto_reset,
input [9:0] s_axi_araddr,
output [1:0] s_axi_rresp,
output rx_mac_aclk,
input tx_mac_aclk,
output [2:0] eth_speed,
output MdoEn,
input rx_axis_clk,
output rx_axis_mac_tuser,
output Mdc,
output rx_axis_mac_tlast,
input Mdi,
output rx_axis_mac_tvalid,
output s_axi_rvalid,
output s_axi_arready,
input rx_axis_mac_tready,
output [31:0] s_axi_rdata,
output s_axi_bresp,
input tx_axis_clk,
input tx_axis_mac_tvalid,
output s_axi_bvalid,
output s_axi_wready,
input s_axi_rready,
input tx_axis_mac_tlast,
output Mdo,
input tx_axis_mac_tuser,
input [31:0] s_axi_wdata,
output tx_axis_mac_tready,
output [3:0] rgmii_txd_HI,
output [3:0] rgmii_txd_LO,
output rgmii_tx_ctl_HI,
output rgmii_tx_ctl_LO,
output rgmii_txc_HI,
output rgmii_txc_LO,
input [3:0] rgmii_rxd_HI,
input [3:0] rgmii_rxd_LO,
input rgmii_rx_ctl_HI,
input rgmii_rx_ctl_LO,
input rgmii_rxc,
input s_axi_aclk,
input s_axi_bready,
input [9:0] s_axi_awaddr,
input s_axi_arvalid,
input s_axi_awvalid,
output s_axi_awready,
input s_axi_wvalid,
output [31:0] rx_axis_mac_tdata,
input [31:0] tx_axis_mac_tdata,
input [3:0] tx_axis_mac_tstrb,
output [3:0] rx_axis_mac_tstrb
);
`IP_MODULE_NAME(tsemac) #(
.VERSION (16),
.TXFIFO_EN (1'b1),
.RXFIFO_EN (1'b1),
.TXFIFO_DTH (2048),
.RXFIFO_DTH (2048),
.PHY_INTF_MODE (0),
.AXIS_DW (32)
) u_tsemac(
.mac_reset ( mac_reset ),
.proto_reset ( proto_reset ),
.s_axi_araddr ( s_axi_araddr ),
.s_axi_rresp ( s_axi_rresp ),
.rx_mac_aclk ( rx_mac_aclk ),
.tx_mac_aclk ( tx_mac_aclk ),
.eth_speed ( eth_speed ),
.MdoEn ( MdoEn ),
.rx_axis_clk ( rx_axis_clk ),
.rx_axis_mac_tuser ( rx_axis_mac_tuser ),
.Mdc ( Mdc ),
.rx_axis_mac_tlast ( rx_axis_mac_tlast ),
.Mdi ( Mdi ),
.rx_axis_mac_tvalid ( rx_axis_mac_tvalid ),
.s_axi_rvalid ( s_axi_rvalid ),
.s_axi_arready ( s_axi_arready ),
.rx_axis_mac_tready ( rx_axis_mac_tready ),
.s_axi_rdata ( s_axi_rdata ),
.s_axi_bresp ( s_axi_bresp ),
.tx_axis_clk ( tx_axis_clk ),
.tx_axis_mac_tvalid ( tx_axis_mac_tvalid ),
.s_axi_bvalid ( s_axi_bvalid ),
.s_axi_wready ( s_axi_wready ),
.s_axi_rready ( s_axi_rready ),
.tx_axis_mac_tlast ( tx_axis_mac_tlast ),
.Mdo ( Mdo ),
.tx_axis_mac_tuser ( tx_axis_mac_tuser ),
.s_axi_wdata ( s_axi_wdata ),
.tx_axis_mac_tready ( tx_axis_mac_tready ),
.rgmii_txd_HI ( rgmii_txd_HI ),
.rgmii_txd_LO ( rgmii_txd_LO ),
.rgmii_tx_ctl_HI ( rgmii_tx_ctl_HI ),
.rgmii_tx_ctl_LO ( rgmii_tx_ctl_LO ),
.rgmii_txc_HI ( rgmii_txc_HI ),
.rgmii_txc_LO ( rgmii_txc_LO ),
.rgmii_rxd_HI ( rgmii_rxd_HI ),
.rgmii_rxd_LO ( rgmii_rxd_LO ),
.rgmii_rx_ctl_HI ( rgmii_rx_ctl_HI ),
.rgmii_rx_ctl_LO ( rgmii_rx_ctl_LO ),
.rgmii_rxc ( rgmii_rxc ),
.s_axi_aclk ( s_axi_aclk ),
.s_axi_bready ( s_axi_bready ),
.s_axi_awaddr ( s_axi_awaddr ),
.s_axi_arvalid ( s_axi_arvalid ),
.s_axi_awvalid ( s_axi_awvalid ),
.s_axi_awready ( s_axi_awready ),
.s_axi_wvalid ( s_axi_wvalid ),
.rx_axis_mac_tdata ( rx_axis_mac_tdata ),
.tx_axis_mac_tdata ( tx_axis_mac_tdata ),
.tx_axis_mac_tstrb ( tx_axis_mac_tstrb ),
.rx_axis_mac_tstrb ( rx_axis_mac_tstrb )
);

endmodule

//pragma protect
//pragma protect begin
`protected

    MTI!#$?@Z+D@Bes*~7\\aDKT{_oH]\;,R\Vaw7?[\~=k<BE6I,a<<Iz3U*m2AU27VeIEB>s_I$;O
    $Qa;/S#Ull!r#~$!RVN^,]Eemp[KwJUz^;}JQ\szxCX<Ys#\V^K!TUv$WJJ+r+=Mx!7VHo$uQ\oG
    ~w>RjuJW%XR{HV+;C9tYa\}xkp#!l*z]u\Db]O@VQ=*3}_GZoXY2k{HY'JRn/,-AWuG{\OiI_7_*
    K#xm=PWs{$rAa,$*~=w]j]jGG*5'oJ>RBk[w5U[<2?1#njW}Bx[-rwK_UEI_H\I^k;2AYne[mK,T
    I]WOx~3B=[m=}*s(kEZ$BiJvYGz[O@5z*$RkdIz->Bz?j'zToRJv\-T2J?Bur"E<^Y~Ux^^mE<{T
    u]e7[pxUW[QU3z$5o!CI#x/v{uUL"vli1+t}i;TIzinwrk'*@A[;T5jBZZk8sD?^)rmH]bfG@JZC
    ovTBi<HOGu@xs-kk*IDorIv-eA$P%GB\IlKGuLeXu7s_T+.I=ADOl*et\=ej>]-vI+D~Y,R3oCYi
    [\@z,@R~\AAYC,pZ7zro}7~RdJ5xO}\CQ772*~XO?*}m{Q(*GCQ*7U*TE?;[Rs#{n;xZX>2u_^#v
    _+=E\^3H$nzOs]5<n[IAO$iD!m\SMYGrizWB>uGiB[Y^O~5s^@jpTO*n3xv$\2,YT2-3I?=^?kOi
    'e3Z#iTH5a<;[$^@[^1s^pB=_X<\RU>nT3n{HrU\oZTRXuY<,?}nVc3}{_T12Z3R2C_YJ!(uh-5,
    -R!K;TX[<RJ]]Ww}xOJ2>U&'@zGWEYmYv*nsKlKo+W@=Ww>>$BZBl_5X+{?@^'JQ_X;ej\nhYU'e
    }B[ol@R3$,\alX@v3X;jW>lZBlVAW+OAD7I]HvzKl~QVps2Gl1'k{-+r>wsRJDUQDCU]t#z<\12o
    =R}ZD_Iz>QVm@5AITC-Bw_-2ukO;Zv;7Q{Un=H,5[FwVsr}-1vvER;KO_oYpOHx@u[lB^C7#[H\~
    5]|An[a!roBmam,JOpZZ+w,_IE>4{+AE2ao@gx-H7K1=z^T<z/fmOBp*+JvQER{I$Gv5Ea=JRD3?
    -7vE32Tpm+TW>XEWH@E-zR;zEkE/Bmn>\n3o=Bl?'xR{0*Cas|o@WJ@'nl7G3\r2nko'7[trNBw2
    G]HI?Xvi'",\KC'Tn*o:#,r\*O{1Jv@WeX-xQwD-}rGEo]-]Toj;[3ra-e!?b<GU-&:KD^]z1EvT
    $IekU{}r,J?x3}WXR>rZ__,z;rz9q,D5AC^{B^#@=pzHH{V}neB!_TH\XN<}jx^,,{XHmXCTHA#p
    E2\+^u>e7]x}<?[}i+E'$~$-+xi'lEm*k~XjuwsnI]jWA5*k'^Gew7zJ\z[Aw7LYZIYb$,!UD]V_
    H*EJPxWl]X.Nx-^xhC,l~Gi,[I,ukVrXA7?^nnBDBG2C]{_*{1kWRnR2{QVe]s*!TAs2<u-w^$^-
    }v'Hu5pXZGk37K<5^IYC{I=ujY5#3*kr5TlCWBUXn$EQOmH^I$jo=$Q+XuEc]v*32w1{\wzi|klI
    ^rBw~GyGJQ!lApC@nz#WE@Q.k$~rO@2'Qu<YBUIaozu<Er7$wA~;ZoH~Kn2K~s[@YazKkawlvQC{
    i=J{YUX=3Is@KRJ?8W11#rHEnLIR$~5[1?+]@-2r[T!]URBts@H{$?{KQQre\[+UGrImhl#B'!}*
    ZksG@^s*OCEeK=Kv@q,aUr^CUOw'W2G[z~RluH^'p,uEWCE<pK1'Z^R]T7)OZ'Z'T]}*uBT|&m}+
    D1~5H3GXorD+Z;rH1xxWYYnv#O2zY[xKRHoaH]7*C!DVrz_[vW}O]r#-r[Sh[ZKO*ZE=ZzG>}u-x
    ';+#T=}
`endprotected
//pragma protect end


//pragma protect
//pragma protect begin
`protected

    MTI!#[eI2DvVa]K@#Z5l?-Q,rI![?p=R;'n^3|)I-Rih?er=gQQ'[Tv-#$G#T|skzO}Zr]=2[<#U
    ev_uavY;V+|EfkQ'Be-e]iXa[zx^QI}VCXjj{R'[vNmUCU[;77CaX2=;U$9{E]2G3,I)[v\[Nmp+
    rQ5U&lw2+?1Il~}o#]2\U2[][%"RvkZG;po^v~'lQ'@o^l]IuQV^'-{s+D[D#r#=,!QlCGV@eYiW
    ]'VYp\}}ZT~>\o[DH~=K'x][s<D]$zAA[3oR<KRA5m>IEA+l]'xO>Q{Y[^Y7u2uWB_ACT*OvIGDc
    <,[WUzZHx;2==JxDAz!AOl\B<[3um-l>,!^kios[3H@x[_u5jJ{TsXVl5=A@D=H*D}kUn-G]}oV-
    -<@}n95oWn[^HYY[;Z}3}s4/ZIsRt]$?j]kE^@'us^~e1saX]*lRsyy1oZ$5D#KO;wElK,BKOkIw
    {H?Z[@#k<Tp*[3R!R^V^*jr^nRW,s,oeAQv^lxQ;A@Y_,K]Qx!5kQm5]WD}J]<*ZE{]}='I!woHp
    vZWzCxn,pD3z1v@[AwB=@v1'BR\DB?{ri<QQjw!nE}<[j5}x>m*WQ*Y3sJZ-*Y!E[~7kp}kO;Ju'
    V}_g^#Z@RKe-x\I}lAa\$BIJc:$~e}4'2ZV\_a?;5[l'l[ez2j[vl1Au<v!WA_xDT1{{[;poH*vj
    ,C}^u\j;{u!duYss"}Z-kzA{*YRR~XC{xf'!I'a5H#w,Ae~H;Er-_op!YlZ_uE'a;$xu!~]-@jh]
    $kobuvrk)OHeCN*Xo1_,}U?vEuNY;KVo2B;I@eiB1}>aCku<X'+pWCen]-$IRJx^mB1Bul*o5_va
    =5ofzr5u\T2!{Qm7,;XE_,;v)pX+~<B3p+G[ueOTYksQ?~'I3]G\_z],7#7Z]\7Yj"zC}7-a7=B5
    =jk-EmPk'[Df<}KJ;{*<2\mZ:[,XROxR~'Cx{!zo1\<I<l7KXHBOl@E2Gc*K^_XO-,I]pX\9GwHs
    m[JXb}KJw<s<em_'IkDGpKew3\zlVxzQ>i{+rhEEo>xa+AB@p}S6Kl<\pZo-'*Y@Y=Yk~z>k\+@U
    8asjC7_l[=HJX;<piNM)_U*-IWpuxI\zlIVCTH3E="77GCBC1(Ap{aEG+w[hsa~27m7z{li2V]Xp
    OZlDN-nX[>V~[m<1l+[3^{$7WpF\;mW\XE,}i<3X1kaEa@o,,ZxL.oUKvi|>Y[-m}[[rvJWpBo;x
    <W}u9jC}A]$mV1!\^nQ{WT>p?[vAH}KOIDB3m9IQH!..uI$[2-\R[YT{s'nzM1<<T*RBQFs\X2Qm
    xr\XCsB+u\R]}[9F&zQ^[]!-~F'HXr>V<,<aO,(*iV~ppV>^ElVo[DnK{EB'{~J%AH5<WV+7,!WW
    &R\7]E{<[I1{r7JlCCT\}WIW*YCa-=DpBsO+7njm33B=n]kuDlX{'*Hw'n+K<oixH1^;RY\G36AB
    xBpK*\+l>Vo}Uj@suABPm<{R)EwQrIJCKO2uOpAjAo>,-&66F\A@{6@C]CDv<WI"0!svo<T}H8Y;
    JaBkol+'#Txo+{Wv1vl+Cjk}"KBEEwGe>
`endprotected
//pragma protect end


`timescale 1ns/10ps
//pragma protect
//pragma protect begin
`protected

    MTI!#{Ii-^w$[*m@jMBUG~VRHC<omw^EHT9<1k$GB)S:3olE*QU#3xA-|-^<='=>;:m=1[|lnRK\
    n@?pHQzvjk}]irz!w$wIi@DFzx^QI}VCX$s$$2[lNflB>mrvx~oH7,a{Q*;T!{,>up^{7Zl5Ax:*
    EpU}}}r7?@m9Vx!UqQsHT1@okeE}]Kxr[l>\zy?Ax^Ck-TW>ueY@psrc3B<r}G&@r=D^Z=KI7X#,
    \o[V>}VIJJeKB_RYkep^mIQ}CHTr\~}IXd_B[z3}}O*}+jneC3mp[^,s',}sk{!{z{A12=[<QWw{
    A\r2{;wU@j"B?5mnjV]EDnp;xR$MKVo<2H3vKsZ}~5p*^^k1"el<Yp)R3OXWO*i+1Qz>]#!sY{\1
    v^[vHD+o3BR1AJr{+Q^#7CU^zYYCO!=Dn]WT]#nDQ-\&BK1YUV;?O[,[jmT2NHBT$YA{O[<,jo^r
    ]"Q5I#ZAz^|:(*M+,TCLBv]ZaH<E'Y'1{UYsPx@w^5rlvl>;AW5^'k7ou'^e{$n@YBK-;lU<'V<7
    Q<lBI7!$Twjo[]3;1rQvEKqB?<\5rJ<}]#jl/:A<,C!TZ3g}mn?6-RV@!7H_wTxuQHAI-eGRoXTU
    1G1Dq,mX[{Gx7aETVAUU2p-w[8{x[Zls-^p;XRzW-[RnWoolR5<C,@zB_*TE>GYj_2Q2,\AOj@^U
    VX@'xZ#\ulI)/UDl[KRGDpmR=gO=HvH]JW+EA!XE,1Z5~D(D;@=as{sr_~!@'D^T[sad7=k$zd8i
    >'K_}}l
`endprotected
//pragma protect end


`timescale 1ns/10ps
//pragma protect
//pragma protect begin
`protected

    MTI!#BD^,8mO!\tw['#7WV-aYDG^-ppH{lG.[%-Y7i}mA[NH$HW[R_Y@I~azV+7#sn#I-UKx<W\j
    *UO%S#Ull!r#~$!RVN^,]Eemp[KwJUz^;};-z@zxpX<o\@O@B}<[p@[3C5?5oa3Uw{zN{,{I\,!u
    }5zw:E{OKwEoe$xkkWo^}e@>X2s<n{$AUCg9,,iRaX]R='D+nt@ojIIzA{sv]p;',TQ^n_7kv!k[
    VuU}aj-w1>5o{ps*Y?VaVA!e]KCsu,?v#oU=K\(E>YlYQ}WfQ?aDyx*ZDS!Gu-n<n2z{5Y'jK+}T
    e]2|^51+i>YU'Dkvp}]=2oD2E?;D55C1^$}EB3@H]KpO!jT2!R?Eszwo1_QK+T~@~7WDP[,H@Djz
    ltU>5U*yXjzYKa_;rX+mj=A^Tos}RLnV-~Q~noQ3In,3DOv1Dv?sekmOAKoGD~T\mk1++s^HC5J]
    1CLkU=7}RDnOKr-]m[OyL'Qo}Y1T!~nW!r2,{E@VDG'_xLE5WlHGDWSH,-X$Y<?{jX@{oz@n$a^v
    5ID}Zlme,\',in^@]T>1x]nwOu=m5e2k\5V~YYJI!O7t]2\Tr#DC8}~\,B7XRXns<M~x$[rTO]rG
    $xwCA^i7iK#OTI,emwzOR?Z7rIva2{pU+YlT!5_=V_pZ5-?w~n&IIEovJ_e_2^j~Y$Q*A{HDomsC
    y]A)]7vYn-l<5$vp!>AD;Y-1K,+3|5Xl]*[~TeT$mJ1>I&!UTv@}xJEE~^O^7=*2l!WX[7rB-$,<
    v+Z\}GlQXZ^KB<EkV]2[D_I>JY3V&E]3;n}mvO@^[\jsEIZYu,>uz\};s|&kVKr'C2]R+[5u=XoC
    UH1i}?]$\*KcA>C2:B@X^7=pwu6pEsvi+-EAzu]>we<a[vmb7OW#2xU@RrKo'pzZ5oeIz'n>wBEr
    n,rz=]@o{HKOduX+^K+so!C]k=n@1[v_o+Y?Z;>_W7n\59x=rak1=I?D$O5A+Qs\K_G#YXAwTTwD
    ~TirXEmj'A}[]':[Y\Wi<s]sK+{l-3AnYuU>YpY:Q_{l*xIpj$EG-1H!DeoYo;z+j$z@Cv\{XeQ]
    Lo[~_m,'|>a=p%?ljIuOkuDibsG[[\w',F(^U@;IKsR:k=BTO5<sApK]pH7knrp<K}HH7!]5;5~$
    7AWkqs+JeXov<!{JZWO@[y{nT[[IQ,'+z*nI?OT]-]];BvXr#Uoa{UUU'r%~[xk[A2jaRwDjdRZv
    eC+57]s^7[Qo\$liB,#1<[$Zmzsww1As3~5r$FG!li5$*DZ+v[}*T5mY<H,'K!~T=uF.PFA^Ap~*
    CovO;lIfp!x=5B+'DO_U-$u_^1G'UT<V/75\Xa>O]w,T}G,-@ojl*D:M.kji+QjE;_$_^z+nv^Dr
    rKU]j;C$,1x!l_oYnM"p}=E~Ox{@wV{7YmruEH}\Jx*ss]1t)\_nuB;V>Q!zJYsoVRp~uoaD2<7+
    Kn7-+l>A+IWeQRo{}u,2Hz7n$?1HxO_W5~X1ZErHU=5axxA_Rinw_IlZj>exE3Cu,k{zjPkH!Z/\
    ZK{kw<Xc=nQWs5QC1r+#sTp*&b\;akZ5\CfY#w=sCGA5]ur^IJXZVuQ~=JJknli='}Y2si=rr1{k
    tmw1n-BmCCnIB@w[esuXWxm\?}oIJE}J77CT=!]XkBO;vlomTS--x'{vpB@}C{]ZV]v<;DXw=~IT
    n@}AOI*y\5X?E+<;zXwWuTZnYXurzwlutJCm,K<Yinn+ok+=m%vm]5Gl^I_}e7rjjU^mUBZIl>{s
    OUCpU>rm_i'a_k~raI3A1T*oCD$psER=1_d1{-so=Y[>w[DC*}i:D-r7p>l<Wr*';U[R\vT@z$Un
    ~{{[zI+]'1o?NY;OrCTI;V}3!q,z=iO<7;J-}~_wsC$$mT_,5,Q{mkBSC*5u~$^p)'QT\W1Q@=@m
    r=YuR-e~wRrQ+T}oEHV1~GwGQ@,Z;)n5{],{Ei+wOXsR^H^TaQr\U$~_]^AoO'ei>]PnT+AKAq1x
    z1Zw>wZqKl{[oAW$E-vr^2BC@,[>>]*<w<\+~'@=pBzDT1Kz2G-*IJoG';eCYEKKuYJ=\VBi3Q$e
    ?B,z-CUC.#AX~d}~{jhEG=1yo<\zjs<uIB27z_UvN!wQjDz-QUxv]$^w~{_wIi*>R5/VkGD[7[?I
    ij^>T_i}iOY1HYi*v@2\_Qpqu[p?z>>pQwm!=|+loxkXIKeiBjV8lU'}ljvjOI]+IKw3*Z*o"<DU
    vnAps!lrO7i~ekE2EMl9]ze;k{}}7u=o)GkXesp,]R7w@.Dr^Q:m&\UKsIZ!BIB3\UX3!CDW<!R'
    C!RKK8;QjjD~$B-9<+m+@I$^grw+}e>A*Iu>@6OrS$IXe)ow5OnsIT!OB1D[{A;s*xIAO=^^mxmO
    3#D[+$(d]l?u:@a[$#nu[/V<J['HH*{{Jjp=_v@RV+\OOB1<<n\kl?ZaWokO5$ExkWfIEjj@O$p[
    V2pJwvO*v}{De7VeW!]TO=H*TT_zpjlB'+s<CxW(Iz+2D-<Qlnw]vO,}t=CD^UVi]a=jxrjku}w'
    pHXx_]~j_Ol:AV;]6B}+C=JUsq_[+}B<U55*[]Z}Eo@QY{~+7u^#EQ7J;uB77oInY^Dip3W*iD};
    =m^v1vXE*O%{HJI~Uj@$,cRlm\7#e*_!!Owo};HU=Cl]A,\QzZ$?J?Y!<H-Yol_1I[#B'Cy6CAzs
    FQrG]YvX$~eD-lx}p['=*6(kw!'D+a?h4A]IiKhme?z1IBo{GV5dH=TA~5u,1kU$!l3]H7B$'eU'
    j~$H$YApT>r^KHD5a5zjs]ApmlC![]}GvZB;lC{rp1p?[,'V$7?#SMxXZH6&nHG23Cw}nV}n|1e[
    o,X1l$HYsUxv71xrH{H5>p@zO[Hn\Yi$I#GQ-,E[}>aK*B[$2#]im[e;T#}unQ@vsTUGZG!l$eCY
    ,?=5lzo55IHVe5kB!5BW#Vl~=QXslvQ~]EOav[Y2JI+z^';;mTR1~,iz_2o';wH-e"--n@A]zw}6
    Iz!UUHsTlouxpO\WG3E*UUQpJQ#[?jkTB;;E[F~+sn,aK{
`endprotected
//pragma protect end


`timescale 1ns/10ps
//pragma protect
//pragma protect begin
`protected

    MTI!#2XzIBYE~BezznC-lQEJ@*sieDZG,?j3@[%IpY"#EY=m'xz/2zBTtN8}&T}xr7E2U@1r*KYp
    ZLv--s~{BBY6+1$'Q,AmOoXA31,['>Kj^<o\-]x]5-n<'UAveQHm;n~mo@j}]v>ZYQ#?\sn?[1Yi
    8QpAWfzZIZqRG-AGz{>2=-Cr[aaY~\Y\_I!IZ7e^rzBUrk$V{nD|_vUu1X-\QVir|-[#;vk~p./Y
    2<$[-\sm'i$E3>v$X<~B,{>x2{^<-w3hl+{RrN]kBe+<o@I>Gw[IW[[XQOIAQ\E>rI9[w<'NE]]Y
    nv=]{{^[YLJHC]>Ux-!]uBG{+m)Vj_msv~uT7_@i[a,Re}i7GJ[;j+3->;}x}+x(#1s1-1$mQA-p
    -}{]|F#7!nl+,]m9BIU3B_;73,WIo-1#rmroNnODT-'Y5XRkBGI7!,\zaLD7n1vGK,O3}?A$BK5=
    iJ?TC]G32\R]AZj*wZ=BBC,#+opMv3*IVwlU1,ZQoDjw'!7^kDY}cCUs!]<OxRkr*'YT#E<e]NaC
    k~O}kAo?_^+*#T5x$Y0j_<1lQa'l#[Q}u7@buI#ap'k$*;1H?RRI"I3{O*7RKjU5-V;G7GrVo$pA
    Z\kIjYYiE:Hrn\1>=wVY#]B7Yi=X'RweEkRnHJx9Bi*>=mOeY$?~5kp<@oTvl#UH:#H}+UC*I+}D
    u\#=R^CA]@$k'D{Vij33Va]1O_szQzjkjR?WU,O~V([l!Oo>o$u-w@;Ha*$p'7VE=ixeJ@!GhRpQ
    m(K<wep|CkO3UB+WQJYC'?VTzAX>OQZ?O}$oVmXD|^\T#RA^?,7*ri}-AVCuI>XooDEnmp{]r;RX
    Heksx^|Sz511>CV~x>Y1xmzCzzi,AQp{{v##=R{aWh&='WK*e<j
`endprotected
//pragma protect end


`timescale 1ns/10ps
//pragma protect
//pragma protect begin
`protected

    MTI!#2YWH82<;GCaRmD'<pJ<$oAA]*xzCR*Ka[q&Q&f=7D<+XZ*Jz{[7a~1D'#rG>;TG>j_G@xr<
    $vm7udOZz%lwJ#*+[[o_n=['CW!Ul$HUlIC7BA'O#}E-=>]Gp<>'i7|1Wr'a*^p}2CAG;{,_[{OY
    CaWuoU}gQC-R|?]?ul~A!OY_^S9cVB+W:1{ne./$G#oKHQ=,7AYW&~OT@-H_CR=+'Eu$2,*7Z|?]
    VBCJ3k]iZutA,WxX]wp_2uI"!QYn$DCYXU77,xIeBep{%l-jawO77d!U+<ne<xj>+$fx'Y[VV>J*
    r7YZ]A=U5HU}zHp1zj#sDm1QZ]@a-J#>e@JoiwR\!_uIZwpx2m;=s!k1'=Ugs+Y?,]QmCV>paEA#
    Y,_5$XskHQZ<}k\]j;A11kK'=TC!r=Dp{1s,YCw[LI]_pDlQ,T>X2u+nOa[nkO-2'pGr{DWD#BE*
    'l!T@*x};=v!~h:?(AQ+^kH>o<^!Cnwa\JD57ue-J#<<R&|ksZU<wJBD7:*~\_]mW!V=XaD@ei,J
    WANazW7#T,k3Y?3x*j@J'w+Q]-H1uarqj{<Bm{DnR-U^-<o{|Nxu{;7RY\5D#<YBj<,Q}lE-jO25
    ;?C>Cio!AknrB\_5TOU>m<\,T55[$~A${uTEUr5Q;H[epw;V!rK'?-5Ur~l-{DC#zpWU;[O1J1V7
    #]{=Je[Y?eDAoY!R]Yej"eu;K5G%pBz*DeA+AB3-QiUD$~*E*?r17WYz]nYWOEHm\pI3l@'B_Zv!
    _HDlm_m?6[QTRxuIn!^x]r!vHe;~~lzH[9:4j}{{5Xe'\Q~^TThrlQH><-K[Jm]=[\E=sOiV=<HY
    -QnD2E51;$rO'{Hm*K\}-A=>rA!p~~eC,U#$nsO>-o~?x>2np#D5Cr@](~IC~kvZ@]#*}S$ms2ws
    's'XC3Bw[J'[X#5rma}nA]$C$*KGEiZ]?zY{XC1A}j5ia7m-Cp]SACIB$5HC\orC&Bs7;,+'CE>m
    {4CRJ!H{T~m<eDmHar#}>YID?nkHOCGQUaUls?+^-]9-_'Bm'k#[V;I[3]uOwp_k-[^]>HO<$<!H
    T^;@C<li5f,U^l*wupEAvW^F_zu'YjB<(1B7TxmKC|8\[lv2App
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#D-$^#OJX@1TJ'7O3on=_e;5'?5QrOA+?7#[?I""k5.moz?\xW]\op[s#VVrG2Z>7W}7C@*7
    BqB2]+>YT}aap<+1$'Q,AmOoXA31,['>Kj^[EsCun]T7C~12AQr\@m[7[smUH7v9N|,HvAu*<j,r
    l_1G7\ArA{ln^ki};{IRHu|=xp<@YWu{C_7,CjwV=];*HD'[<R>pK<sWB;[l1_@5OY];sU<Us!?T
    1#<LBW1$O_pU=*Ru/?_W'se{]SQ"!_l7KzXx$=^#e_\X{}U!W1ujK7>pGQwXllUjupxm{Bn{E$YV
    1eT}&-{{\lB>Cw_@e(YuV\$~m'W]Yl|_RiU+'5!1_DVk\^[II3'$,!\.<R??+v{p*X[G|E3rR7!O
    nT}WVY,>7xx25AD\DWo>H0;E'aAV+rt_9X+_i_KYi\]7A1_nn~5YKS|.^Yrik]\+ll@QV<}HIs>Y
    vHZVe\mJE[i3EBu[7Iv{CXoTg[JTwn]m$uX+Vp+7{Q@2*|MOL!OBzaluYOIKO~w{E+Om2ZGp=}D@
    UGmzm6Q5'JA+K#rre'jsrI]_JzB~san]!>0kB1vsB^wZw{]lev*1R3@o^k$Q_I$>7nkG@J~jpWRl
    x@{OJ5A[De{-HY5XI~2Z{D[z*uQ|o#;sl<'V7KuAAr>@2-YX5kvZ~HYYRZA*mEmnvT}i;wXB9-za
    Z0klBpeE['T]T@nsDupZnR^C;JV'r,8wn+>OW]VOX+-o-RKx#W~S+=!+\T3R~A~521zyCXDYPEaz
    s7[C[<U$,[Je<oi]#;T{wOX1VQCp'i^v5f,ij_K-IRL?Eh7.y}X$E,nR$J{wzewUe&@*a=Q<a=p}
    DC--<K!AXG~CU+h+jJRtsp-e7K_kpz1~';$lz[m^;w.WH@-[Ww2_i[7Y<Y^<'GQ}!-zvK_z=JORz
    \^n_\Ba&|}@\e5~B~KUO]Rr{U\R]if.V|QIE=77?]CY#$l2UK\*HJ
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#|al^Js_X+OQ~oczZJ+J][wr<m*=v7idF:N*"";'<<mjRe]\W<J_p[RZ+wuD5-VT3[D~}?,*
    @u:j-ns~{BBY6+1$'Q,AmOoXA31,['>KjrBj}-]@]Ci[TjxQzG?ve}i22AY[iF:Pa+m#s5T]*Rz{
    xnm;ao$]9lWm~$BUU}+jC6ZQnK0BDF@DVV'xjCjiI}VW1{T=>x]U-$BsET+T2<lsT\yAU^'}U!~Q
    \}'s3V*\?+ZOwB5?e~CyQ+AW$I-Drv*==iJTeei3wY]]_[-Zaw-'2XUBx$!AuE5Ix*uD=dN1@~O@
    n*\d-O^Yl2XD$!=D*v+#]WUT;X*{7Y3Z_AAB;1p\L!_o<zh'es+s>1+Gl7m@>h_'B{=CJkxm2aq.
    dw-1!r$=?:UpuY:YKl5evi<c)GC*\V^}7jGej$+DA[@sn,aBT*s${G;<TV_kn]GT]m,{oH_GjIZW
    vAAe{X<!jTBQ_xS&$3wuj~W1OqIwA$V{YAO^I=G;E;,<7C!sBHAI5i,WV=Q7[WKCT7i{A*=*uv~G
    R^a5^a5o#nC'Tm1AC15''D>,1@QvB!T_UnwwDj1JRol]I=k>I~Z>l~,nxOr~A},lC,wv}[iG>pI~
    }5\=rO*[X!flmB+2zeD_m@1<=e}nrp#U*J+ua_7>wZ>^>zZjDZ@*dnGXHJYwD1O13)m<U@l'#5<A
    ovGnVm8J$wnO_n\L|j1-V[4Ws>#I-T^QDmI=lZCn1JR?ez[,'5[!{ww\U$CWOv@Nk12x*1s_7_OK
    AaT_ws[KUrXK^5ar+n!]aA-H]=1eqWoZZ1ZTB!v2[<C+vx>QI~{VCDvmmB]1C_In>xkoE#5u#5S,
    Cn-T[3'uRk?\$m7{Ewl$-!WxVx^B\+x*BY1l5pj>+Z$cqeYi{P*$p!fjjDQG}s*e;@ZdIx7Ru*zH
    yviAH^Us[CDm@W7Yuv+1Dz+!A^{Wwi{]C'CO]pV_@gZ&'Q{Y,lZX5Y[Ua-a\Xa{[Y}Q><oDkzp7W
    sM]71I'2UHo5nW_lA7OKHTo^BX@B@;i\OnG'1zK]rAYX+o^3vzw5Zz^xIpm*aIBa}@<DT\o+rCtO
    7IDI#O?/3To#we}BolCw[A!?YOW!=?1H'ru<mXBA.'ixDT]a-IAWVZ$w+pZ1AvnRs>$5vI}iU,,V
    w<Tz[^DG\!{]_vRzl=wYG]o7\5W'#wEA^z\Du!XJ3kIHs.]!e\^^53eeYBG!}C{>UEx<$3tkHW~e
    ?!HaQ@a}~u3xz!u?,<B'~Y\]sk-rOwo^"eoJG@Xsp+R$vs1!uq1?~W7*$G]G7#[7='-,KzUnVHzK
    QB3IzUT1;,]Tp<wUa+O'*Elpn!O=Y\Q1^<c}~^zBEW=L}pp#N'$WK^~xi]1><D[!^,*;oi=[!_TJ
    ka+YHp*uAIo'~VI{r%=-}!vr]{*5IwCvU^pGm7W}G,7OVX-},1v*Al52R?T7eB=n=YYp'!D>I^#x
    5xE^Xo.i-+R]&B457x_|:H=mnRoT,^zFf!Vri{DZ\:@Tr>K}DRxE!x*;AW#*\l{am$,l~OnEbD{-
    EH$^BjkDYw{CVsApn=k-R1ZGB]rRokzzI#s{#aGGj#[-2QuW?=~Y,R=\Ep;>]3-I@Y><t=~=~wo!
    ~3QQ^]}Ue{avWCQT2o#3>'OWHXDs*qJj,^lT1[+Y-3;_$p[T2V[U-xQ]QuAHm;oC^=TCIolr5YCo
    ZGeKEXMqQTY5>Hn2>]T[TAvse>nJoWak!sEWv1uQX<]H[m2E<[Diz'H<?wo*uOnj3ED{BEaBK^w=
    X]XB,!JZNWv1X@'C3\?lW{XZ~*O~renCT]<uw^iDJ?w=E_*I-sTm3qLskOlIr^jPB*+wz^]rW+aU
    <x#D[7;r]7CeQ_Rn74~DsD$OQK[^]vjT~YzE1i2GO5W]HuOXn!rEZ}V3,R/S>xU^}>7;V\_kr\$1
    kn<Xf~G<}7T]pA]vEka},1nAJ\;@3w^luirkJWEIeY*3a^a$[hRAx=\\3]X]jXsZ7pm}l2|l[R,\
    Xe<RKrze2w\2j]E;*++QaT1_ZTrv>]*6.BDX~}s~GTXDTBar,3oIGie+]r$\5rr\Q[OIK[@pr7\r
    1EA+^Q*,{@sxR[+I+QeJ1CRe=_,orY!lR1ja3?_ue]2@o\5i1Zz;u1s\#fVlAIU_~]s[2Cv7D}Ew
    U=RY]<N)XRl5GGj~*3~DzG\z]XZ\Ev-mRUzp^_E5\*I_{pCeX+H>v3e;8c=1,nJVj_GCRUx\vHqK
    =_A>p>B4iY,W3wX;#Xz!=~C$}2YKxOv?BToC=Yu3<>]vZT1E'C>avZj,nT1AB']wL7n;Xs_)~7}O
    1^^Kis]@=uRYmYsv$IWIHR;B$ioien}D=[1z'[?e/"c51nuE-_YHUsVT<^HRB1o9Wzo]nzT5{E[G
    ;v<7$7Q]-p$+nl=@H1r+VUDrw71sW5jlxAE?ttH+2rw$n^i-r++SYZD<=EUD*mmmwCUm}mlmn=[A
    YO1DR=YuSE-*~iOI2*HG1CHHkI3^DO;1ut**X^;7\r*~WUQ+}w^2[7'CW$w*wVT>;o}Jp'iw[Av;
    j'3oX'.]>7$ujXUe1@IK-lle#-Wo'QR5HGT$Rj3x{YO1TKsQCDKJUVXG~jV9u]^s*pY@1wH~$\IA
    _@-][D5H51_pC!}_E+Xu3>ZV1+K3j~=;^krZNv2K_vBK*@pvp6iAWu7^wrC{!u\oTU5oKOB>D}@=
    AIz@7B$.*i$_k*a@'xa@Zwv2r[<${UZwuo$iG{Y{#TU[1rCu*{@JoC2>j1+B^Ko=]eJuR<XG^EZQ
    PEmAX'Dke-5+mR<$![js[;zraEe_{JA,jIw1R(lx[T=>QxaE12$zB3X{p,;[!?V:sO5W*kX'^Ov\
    ]*]HEC{_lj@2n[IA[;rnBWv*WO+=L3aY,5I+;jI_H[;H[-I<<k>s@)@aVCWUusmwU!=VxpO1T]V,
    xC)5_YJYw25K*!~*HOjZ*vImpTp\vi{aj1wIV^+HjR=v73GL<OJQUpBJ*;x,3xz77xAwZU]_SIZR
    vCs-UG3;e'K*Ez?511(72D!X=eW~GJE#,mpZD>uoaApwR*}uj!*>'o=e~<~#llpvie]r,ZJvpw<$
    !UDI}l-@-$?E<<oQe'n{>z!-IA+b3$13Ha3m*CX1N:pHYrQml}mxKQ=>-3s4lJ=uoxY7|Z^jH*o@
    =?zwKu<!#BDY}$\ICpux[Z=kk\DoC3A1uX]G-r<KEhDE!ovnm;GaD7_KCGAB>'sD<^GJ$!=wVRV<
    2wjEnsu[s7:IUY>EB+KsW!ej@;oo>A\1$JlGBEDRkx;!'iC2}j1QEHppUn{_;<^[uWvme{sSC2-J
    ,DCTW9?N5~e['B7zCXH-1pnfN}IeW2>a}nB-,R}<n>]rp1\-mJ'aR\mH,DpsQ]7G}Q!'BmCu1G^p
    \x{VX!azVOxvQkn7iO5\kwsoXl'$2BKA2r_oko,c5K'H@}^\+^e\-vQC.qVr1k<QB<O1mOoCkUsV
    wwErJYe!xxm7[{E\Dsp'?Wf&Da1a7B-T?1ORBG$wlr$*2*[ApYn\#62RHpI?O1.lHoz]+@<<X,jl
    ['r_2@o8I'~?[a-mfVTQ$9Vs}V1eX+A5\UKvkBxC+2uw+z7V=+$Ow_o5Ov*9lCZonU+!?$Ul72*n
    }B-}^@]1ine}sK\n1@rx\1e}x@=\n>ev\2KI60/f.Q%+<j=lr1]lOxB@lW[rWm<U1e}>pp$--*Z3
    l+H/1_{EY>KwD2QG,ZjEC?>KOXjU-Y>Boon2]'~Q#Y]^2+$u13Z\>rOxD#rA17<zk-]o?VXan1CW
    YJ13p2eahIO[!}_rG>oVjo~R,GaxG|[H\j&Oi7aKa1W|Jl+k,O2uI*}\L*l<$=!riV1[r?omw<{[
    mp<Y-ur^KA<wK=@}^m[D{5I<?B(}<wOi[+!{Gpn{o=WmR>Bx$HKpU*,YOE{QOVapOo-P!{a$n5-U
    !U-ByC#TK=#D~uVpvA}$H**3GAsA}2xZ}2woisVjmBHRmGSzi}53+]7Ii
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#jxQxb{H$WuE5w-${3>EvuDxAWRzO_2O>[\?WY7"~Vv2elR@xx2uERR[}Z,>2DW-\T3[sm1?
    _Y3Jq$--s~{BBY6+1$'Q,AmOoXA31,['>Kjr[k<5@B]Hnnzx'{z=V#;[7i]lWBBu[l!AU@[IQ!~Q
    C!u=zo3s?ED5RRej,2s,2{z$c{^rn=ym[*}*]+<13@_IK}olIB-bG${Y}x,QNI-{EC?a~kX~lp+{
    @ITA#m[n[oR;U\5o@_RY7a=~oB@}~]v;7^He}5kl><zOol{{x+-}Yfv<__$B3Z*o\_nV!D>E?Z@e
    T+B2~Dw>uEupDiRLt$T!uogx>Zpy*mlOiCYBso>jv^<jw_RIn[T[[/37ue'l*,'Q2'Q^Rp=XT7jZ
    RT3{+Y=I}$spsk5-1jYjX{[T;2;Y+>'O+Q@pEl3r5,Ex^lwz$p7aaW*!^!aR@su>=z%{}Y>p$-BJ
    ']T}5!}]~xWYulewV@o#L5o*]Jv7JRH@5)7*?=wDiWq=vuKCO1<e;{u<jA#;G-T#RkZGIH2oU**J
    rA3{5+!OAWBY;^QO=s#n$*aT<3;yEfKs#^i6KwmlTRi#B*x,e#Q?PTn3BtoA'a6sem;zWaJN1KI#
    aw{;@xe}W1G]JO#w3DZA=F>p,]}#I?s]A'EmD!7TAp;'[HVzrkznerwTee^Q'Hu*<GUC^CtiRO;w
    12X+z-;p5{VNyRA7eTDa#oRXvxn3Ix^;Cvlp{?_5\BnU1XH<JOD{[Z$_H,p2{v*JIr@IkzOCR#XO
    jp5W_Qw,2$2x@wD-rS6NW7}n/{7ll#j@n3AKm}A>G3aaEd_iVu]@5+mB]}$(*$1T}GI{o<CYriYl
    yGrK1V{B]}lmR$WpV,F+T}$xJDD}H$Y=l-Xq[?_Z>aA[{n}IE#+x5R~AsO=,]\wKjH3AICkGo}wD
    #\-*]I3Xk_o^blR{>AeRu,*URrs;=;{~XJA'oAwW4FE{sp"~rTnt|3eR]2I/~GmA_3ms}zb>CJ^^
    I,jan@^'I[pWT*XHa@Q]JBK>nxV!pY*fJn3GOW'$'IA!BD=_sp[I~=O2T*G3RQ+^B#x\K5~<H[kk
    DXCC8T$UGt^k\<5i2@,p+W*$a2Ew\\^IO>L'G2jE@AUa{J#6Bo@WkH@JxA*r*m'jBsmjDW=WmasE
    i]TXjEuYa*C#'R5QY"+pO5h@xR\w}eVHw2C+jo^eEQV@GJ]-G-3\J$$06^]e{cOJszO}6vJs,~*O
    -7DWVF3axGlp{,=p$5owE~^sE^HIK^kH!7RnY?>Y[TiEV+lJK_awm-_jrnZ^{}~$OZ/I7]1"z?=w
    !1Q~x;AwXx,+E=;p$!x+o2*GxGzaVR#p$H^![~VG@<o*Q*@Hplr7LUA<V}Z~zl5;,nGa{e2D#'__
    Vo{zCsjIZ@\[@+w$@!nX2YOVojCR*-XvX8]?s!moQzOAIwH-TTLoaAk3I@*hnAQ-#znRlp]Izw=!
    sEH5n>xR7Q>Vl{Z-x-[,;_TaIjao,{p#xXpK_;Vz#YJ!7'{^kT[mZa[@iUwv_~\;rVBHG1Tv~,lA
    y_T*>p1K}6neA*A<XJHY^!C@J?;[A5{HDiQ;]UDk$2J^ks;OK56-pwrrZ'$jVkr/?ewB1;>1+a>}
    sC1mx}CEFDHY#(D1IJI>*IF*51ikws+{EH5C7l>VvE_[CsekQToxIJ*VprB|$<,r^zjCj,K=;*'@
    ~rloIG5mD$!Be,koks1,^RjC>l#vkn]]6!^l'}@[$Q1^\!1?>VBo[<w5-J'1x@5k!3$K2,zw{-LQ
    $s^ErvU,UVWvoT?>X_}jB~}KexIx2rnIpG^GIzT>sZ,=X@rAeoiUsl-}r#~=l};/rrz~'@3k*ioJ
    CB+CM5]W!?[-v}AD!qj~+XGX[*kNLfuA-j*A!!X<_xYioOzu,#emOHw=3eDXC+TOssNI;VCDn]zg
    EZj28^{mo~>Y'unw#1._$#lD#,U'w[B7'KUoADou7VR\wzuQ=@<b*_\?xr1i]i_#rxv_Z][!?s}[
    m7BV[Ze\G7n-sw7ZVn!k'eQmXDC^s;JsnXl[1{3WT-3u^2X[e;sOu^kZROl2O{^?JU@oOIReQO]i
    E>,CsmAnyZ5'TIYDXt;T!Gr]wI7mx@rpRsoA{O)@GRKNTeKVDD3IXV=GHQu<EjWD5c?vJn#>}+Aj
    <mzZ\XjA<1Q2ez\<pQpn[GY;DDl[C_}e!n#I*19$O?<Dw[5xOJEljvx)F77$i2[pQ4GC$HxG!u+U
    wx's?Q$x[G[HBC+U^1r^R+Xz}oO-*D#l3WD\7J)R#T~K=E-]e_'}31C?j,Vo7R~D{$!.}ia*m{eQ
    3x#kEj}?+XK{*A_p,Q'Q/]n^>!s{Bx!-Im7pi8B]x[sHjiAzEU/xUr@w+]e,{{n-*OBisD]$^}5A
    ]nQEoo=!>d^T5{Jl[XEv;Y@rACpEGzkGOK>ro^/U|-DB$s#BE1<Bv-lap]aV3n\opGn=KHViRvUa
    >kx2#]OzXUn@eQ7z\>a-v18D8lCI5Lrj?rBJ\$^JHD#O7[lW~7:HjDj8o'uYoo_*1]_R'OksIU33
    v{^x=>;jVauIv@HCCT\WRGRwI\k?7O_+wlm!e#lWqRx#el>;@E;r_4ETwQ;G!I}aD{p\^+o?=\_\
    -=2}a^tJ,l;}}\jx'DB*G?_QLeOw!5keEslkXOeCk^sY?aU<;=jp'TUar;^R3'l>35GW^0>5=RcX
    =kU;9GDIY*\YQZ>e=4]UTDPo_Vu']7xp=u!G7*XiG2]u$7X=$@xV_$12wVsw=G<,lZD[T<Chj!]#
    .'BkrV*ZE!+5WUj}}2x]aDClE@hm5^Dq/}DO?z1Bn|\p1WvY5#;l#J}GK?.,i3lXa,QN}BsEV>$>
    tp=J;JeXV$D+kx?^K{o_AJtYT-H+ee@m*v3X^aX]\JHAownT[{-WR\$7r!?>>KxY<>RZI],~]5HY
    i<jZoYAleJ7K_QxIO3H}r[_;_K\3{3vY^1&WGJ2Yww#Z5TA}ouUC7$WYmX[=]a+7WoDX'5G*e~IA
    $kJU+4VZmu!_$x=?<ssGXZ+11RKXsDvEs7,wmBB$}z}V;Zb4wTY}{=G+Ee{5[<GG5AQ}1a}Gmw<{
    _~s+5TaJ$p[#mw'2I-T;G>KpQ!HZHOn{b_CeT?\~$!_n]o',_uAz<n72'@r2~xiHEDrD@XYv!G^^
    !V@}_eVnRVX@C_K'?~U<r~>Ix2Eve#_CHIU3E]\I3{^m{!_DJjW<aIu<x'2U307iTpz!]3t?HU];
    v,ATp}G3I\3*^2<Ys\ly1!e'x7?Exl27vm,\dXvGO#<xIY1iu@-vnCAZ]
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#)AIEXg[QBzR^H+u{u'?r{E/Gpx_oxTH|.mTJ[co2XK;[x\Kl~$-_!Tv4jr3Ob?5}['ZC~{r
    nw<eXazxC[EfkQ'Be-e]iXa[zx^QI}VCXvo=Iz<DNW}#zY3IAoLCKHs|><ju!{jrTooxdl%$I{7l
    @~}\xM}ze}RixspTzY,jp[;oT;+r?QvGUH!H-*#$>p}zz\H'V!iB@-@G+xp_T>^}}{t*~QYVD5$r
    #xmQ*}]k[o7WDErZC#wjJTj:RE@-'EKjjX[*4XwekI@_Yel;aW=}pEYHWDppV/QaZ#$vuY,^kuRj
    p~]3Ov=5s$^;<T.CkZ>Ir5m@<EmBW~@.e#z}HjzACx'a=lx~Q~eK=AoTC_!n?,$3ksJCEH}EmC'i
    uUGT'Qx;pD}GlH_\w|EiK{7[UmvJ=Q8XE@]L.J'}RPH=XHkYnC>[Z~.xm+}Z7=z{T@~aCx]UrpQ{
    O_mkA[v@,a,rfC,nI,AlpL*>-sEpQ=*R*?iUX=n-=7TH^]bH[R,e5+Xu=C!5G3@HoT#}3>-'}'An
    1lo}^\i-Be^[J2Kv22eH,R{&q*+,m~RGinwJaZ<W^zKX{2lpZ$,ka_^g,xwv?'rU>{nOlG-De^u?
    A,O#}>XCv}I=ewI@LsZ@@@GRp<(sk,7Zve#2*Zp]=kprm'@ZB1uj[=A{zB^1WK@H$U}Upoj}^mD'
    <;m7\R@o<_39a5D@QQ#mdlpIao'\]NRZ5#=a5+$zGO*vken>,[{[m3,CmD[HZE+-,\z<CB~YoEq!
    }n7$X5r0GQ1w7![Y4C[x#<=X^IU2kkSKYwUG35a>1R+WrZYj@TWg\C!Ik5[k5uZsR;;XdlvQ~iVe
    pI}WAC2T_4}D!2~[CQJTmrY@A@rip**U'e3>nIo#VGXETC1^e#b\Aa*ewp_2G_,0i5monji\L_+w
    -Z[Gz9wl7{31G<EZe?IA3<7zkWz1E\nC#CB0jvJoy[}rpx>X,B~+seiVaxA5{IV][Yr}jE_jTd0,
    [skj7QvO;3\9sI7EH,<{B<;AfE$>EvVCu=Tw>\*@5QD7u~jO]Oi~2y"3ejuw,z~R#unnr=,.GJ^v
    V;n]2U5a*s;#RD[o)ei_X'uKn9$3529Ex'+;]mo^#K-{,~KG]vpxuIoI23}eVB~7[B37C@<>H[of
    |Ux>',oKR}YElo32[Y~;-B'CnED:]OVIiR1I/L%}~3Hi7Op=6GEW$r?r;Z^VBADuZKHZ^PTDpkoz
    ?Z;T,VKDXoh-[TvB+D==JTxF%x!Cj$GXkIR7WRQrY^}@k|Ciug,)2rC[{5ZjG$\R?^+p}Cx5ZI}U
    JpYe:n\p!2}j{]w1YVwBHzJw5R~Dva5re~RGxmX~}!j\p_?u3]}kzO2*E{,'T}_p+,suke[ju'2G
    KUIa>z@Y,n{Q+W<_~3<Q{Ol\\9}RE5'E^wG#W=$n\D:QY<xH7$mL'}=537+B\HB3NQ>_RXUI[aw!
    @r1'5KVE'r!lXY@K]k=l1}'T,!Xn?YW@AR_evjMImV!HT;oBXC{la3R7xTUrzo=%UDpHso?;djHO
    K5ZE#^Xs2Z{-?3rr^?U+~}[Q3YaXBLEi+oV-]BDv*no#}+#'zu'f5GIx[]#<:-j&)jz72VG&O@*~
    7m,*OslE>I[i/2T<vEHC@=(!Y}YI%!>!wqdA,zaw^Axr3xnI}{3EG?pc^>Z+>Rw5^e{^P;*<k[[k
    \>AO$<*Z\;z}QvTo}wNhi<X?_?}]_5,j:)w1H]@p*,-xKzre#3jB\jHITuTEk[5iCAz^;#{[,Op}
    u_e!OwlIn{=m@R*IAREm@;QblmapTep3fTU[IEoY3kzr@mI[Aj->VDeA@=G<wTsr>-I>e[;\~<1}
    BZjuAE]WGeZrC{vG_5lwG'm,z/xiAl.~Xo[vTnzOT2'?{]T<BK_5G]o5Rl[\5]_UU;z[k-]+lml'
    #I^o_}If@oz^*'upIlx5B=]Oj?}!;<-pFv^5vGi'?&&iC]{sZ=z"TE12zy[=-pB~XI~A,?E2QIES
    aza-ZD\xB>G3$C#Wv'7CR>lYQle]=#~J$*-KX<-$,vRI6r@-Ykwl*Y=jUonY+nV?A@rnD)52R*'3
    AXrsm'z'^XoIp^vZ{JvHzXQlzwGU+<0[w1GU\_K%@j71[iA@|wB^OxB$^D11ui,v-xR;RjXpGVB^
    T=C<~oX-pk{vC~TuOvD2\,^Vwk+DpG^1>kV[z,E;2iVxuX1C=VYa_5x<]'TZ,<OwAlXZ!e*De{,C
    J#}V]b!]!pil]pGK1OEmH^oa^5kA7!15aGfsgDmK!T\2'oYH!I*3$,\+B]IB~yQ*1Y~_1-+G\{R}
    3_s>IKD_Hu&*nY1R~po_la*e~GnzuR[z;QpQn*e|GpiW>D<oB7A1RriO\#2>CWAm_TT!u}=$$kwE
    T$$X<=+r_u{z7ZD3?GOW@jA3Vm=K>Dzi}@;BiO+o7C5BavH{lJ\zlzVJCv+^O;$eI+OB$J-=Qt^I
    ZA2x+m}KEx{Q-xQ'7];wXHWTs>_Yms^pj,-Op1ivzYfX<[7l;]JB#aC7<EA>v+rk7}m!xao+n!'U
    \B^T>^$vH,BrZCQQnr3j_]ZYM}-o](&aO?\,vKux5xW#XR]m52<*_E;YO+uOB,V7">7wI1TY?_[j
    !VC!wEuK\\1lk?on'7O1Zx_H1lQiwNv#SjHK-lW-^pY"iRCoDanX[GRkA5P?62-m_o77e!wr$zvJ
    Kt3[j<}Ij^,Du@$VGAi$3X5-=H@,7jO#U}(X-]TRa{2*7=;jAr2hHQ;73Vk$pmYORJnlORkx-xnY
    4y'O_ZvK'r7XaV[r[e@Qxm,_nX^_a7e+*1g@>=-_sHwsjD5]{nVg(vKC5~}<'E5Z~R3v@127W_1#
    \UXWRYQms,Co?pR,l,pkrCAw@xrv^;nz@_\UW^VrxBJ-;Joz*hL~1ZYxD@,1Z1{=}n?l3x}2B+^.
    A5UX-+voqvvVX/N,KxEl5=AD,iDQ;ujbj}2@oKXlDZU;wj*2luKrpoO[YCIB_}*q#*Yi7BsHuQ{x
    RT]u7UA3@]X-{DO5-T2Q2\H@m+B@WxJ!SdkQkwl,GwKEr~z[YGJAunZxNa1^a#+HC'@n-[T]3SsV
    +IZ>AB_xsp;{Zpp@+jWDeDMp!'E}RQ@}sE<]r_llXT].re>3ssDTHjJ=Qsu]_HY-'G_vIBG'v-H]
    CzBpIR7DzE#U\SMYop^-Crzx3mu\r$V^p3uZl!DY\n1?$QY*>o;-v;ZA}j2peWY;_1$x+TTI>^?o
    XBiaRs2HBJws!w,O5}umle\z7G>lnGG5;m#=pj1,zw5TwA'?TXlYlVOX=\,k]<xYv~k7!1n#<^>#
    aC3CWl=Y]2$WID{RkrH%EV,-JRDp(cC!3oj-5Rr^^xj<OBz<r~>HVR~7s148-wjErKODjRG#5>A*
    3eZ,Rp]}&ArCH!Ea*3wQ~q5]k?jTTwL3AmDURVuA}H>spRsKo+npWpzQ-2Z$ouk;$][4DBJoY,'-
    B_nEy{=,i?RK,RO{Kuojw*w=>z5T3m$Vp2Gpucey=o^?u}wWQV{Dz,rpZGUK5Z{[n,T~UOO=^<+U
    *WGsj3KCJz*J1j<I?eu}B![Qazl<M{w*$C7H[leK=N*CVW-jS=YQ;vi\*U[{sQnAk%ZRT@_k~V$Y
    @]iGT3/L'<a=![[';YvKma_zp;m1'r-xVO}orE\{HI;a{\iY5E[21Irw^sGQ-Ds2G;x3s;RV^,zY
    'mTJqQns>n_Esp{!'\-\$a-Gk3<'GPYXxzV'55IHBs@e~B8EnaDmCK]Gzk{'l@3KoZxER!_zJ3[<
    ^]#,C>O_e}1JGG^e;K$,6'+}BevVRoZ1JF?\Ql:AY^RUT$JYOjkOpOH^]-T]W1>:]=GDvJvE*2Qe
    AvwrzD@@xQu[Jn}or,TIR{n3wI55Q$xHHQ1l1ex@jGz2$jxRA><IDG!G!v!s^_'z[rXQ];p1<E$-
    LLMpQ53ECWrCKyOWQTg^mV>z{I7jzlWDX;zOrTeZ\aKCe53_x^=2VpJ]lHZsXY]+1B*un',vl<?2
    '1J,$w;*Q]KHBHJ'[+GD<p^DpD~G\YAC~n,;>5z{GZX^G,a\,rOsX'mBX@2;\IBQk35fTDzJD1'-
    D#\-G,XH#\*Os?e?5IzkL6s+}wL*olIJ$w?*~V2hCD5w\!l~Tln=I)T]!TY!ZBGr2Xx%\Xo^u_HW
    -Ei^=xu${CYH!5-[ZImA7vWasRRI=272\*nIL*i
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#h{ep<['\]!rsR,%sv!K1,<XGul2YC+[N9e>J[v~AHw[K;pQ+-c{-2}6[u<7?xl$#h("H=^x
    AtxLzGC[EfkQ'Be-e]iXa[zx^QI}VCXvo=Iz!'Nm'i>l_$7*ReUs\<7Z_pl~T{ZpaouE+nm&/#[X
    u&C$<Y!T~QGZ>]2=s#*KRnE$wAs2{QPEwo}#57o:lxeHq^Cz?,<WY55sz?Y^w-CkATTaAS5~}7ps
    D;7ml^?5*{_{BEz;]\1xa>Ts-A^}-zipz$,xHTKw-G^B!!juO>:]AJ@r;_{ijoJ5[<!_7HR$<T^}
    @zG2+32sa_,]UX,|7;'Z."Y7K]mDxm[C@ulD2<%R_<Y1{x^l3=<E_i'2'@1-Hs#H$mxx#ZY2o>;E
    HT@?j}[H.M=s];xz1wz5r{*oQunV,\nvRJYH2AIv5Ku5aTQv<A!pD77Ta2zmwVlo+@@V^}p^ERv5
    ?soAeke@3'8AsKu$U\1Y<@E3$]iQ_@#uEv1-[]rIzU]#=mR,>;1?A{7],i1$^@<#]lE>UnV1w3p7
    i\wBCK$_7TwVT3;GssV?rDm7Q?r4+*3^&iT3?1d'*o~OY_B#'BJQX^]-T}ie[Ap^?f?C'Jv?n5xO
    :ET7uUBn]Axp_#E-x2nG^j\ZZ5Jwv$zHv5{^#xY7rae7-#A$>vMkEDm4V-JDT*}\J[V?w'Rw1wAx
    Ge^YM*!oJn52]P\JDu!xl}k><*u]iYaY\>7)[JTa[V[mHpEOl?$j\z'Ro6osk+!'QenAz-D2Qj2Y
    UI$YElN212a]=1^$iGW&x>5zR3Oo@]Akn5Z<v;}i#<]VpiT>';jrXDIQU*AC}'@kvD-uU=<-\O$Q
    2*&3+3RQw!BI5mOlA>E\>C!YsE2lTwlzY-=rG\,X5}iYUrC"43EOXJ7+r#rA7#^m[,VH{XD]jrK<
    EGuTuVV,lG?p'H}Q~B}x1(veo^,ixw#<pHTV?nGAA}Vs#wIUKs5}I=h1k{16'55s{z1ooGrYknsA
    e_r?Te{<-QnG;[r7_+XCAORiQJa+se-GlxH3aQu2jQuJITjx3pOp\<v#!E7D+}DKS-\wYz>w['r;
    rIzmG;w*~jxT;@{E'^ax>-Oa2'z3HvwDujolwj\Jn$nrW,ka@'EiDL3,WQ*V]$xi'#9YY!'l!2p>
    AOT>_RIGTAv]nsZo!,;f5parC{jJAE+@!7m5*'pjiY]'xB,?aROvYJY5lHHj]]>QRKI5,B}B-$^O
    Fz^o!RTTvV@X]qVDu]WE<OoCwDAR[BYeA{9E?VO$37{}Z]'jiDK&CuIJB+W,Ow5=e_zsS5Vore[+
    ALZYj56YI{]w[v>R}!3X}7i#auX?x'\\x\{RpT[reWemv]1->W'YHjakX~VIue?RQ*Ugh<U3DKD^
    >5i!rpJBjGHYz7}WwcG~1HHh3Tn,\*<*zTJX]R#7|[{wz5wlR$*W\-XG?p^X]QoRpO?2Uy^mj^E5
    5[\U1DYGiD@Eus71xjl!*V7GGu=^\OrzURIlw=#B}e.E1,!ho\Y\IWJ;z;WQ)+E[mlD+W.[nwU>n
    UJUY?p]}@1O=xU{-_]i-G'E|zXK^X>+CF=w7}R\j^*R_BGDHRBuQ<BDjK$U{p@rjuZ,[$aHKVGY1
    !+__o4Q'X=o#*ClCCk(NdYa=EWB?k
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#j{w]9Qp*]37?&Cj]E;<~Kxw$GmwXzZ'#aw1D["Go-w>$5WvO0WzV[1;5KuYUIYW2$2}R*s*
    G@fV-ns~{BBY6+1$'Q,AmOoXA31,['>KjG"]ZBaLHnnzx'{z=V#;i7i]:'J@o"{XV@|IQ!~QC!u=
    zoms?ED5RRej,2s,2{z$coErnFokv}I!x@$W*-+R{E2r5aTqG${Y}x,QNI-{EC?a~kX~lp+{@ITA
    #m[n[oR;U\5o@_RY7a=~oB@}~]v;7#He}5kI3qvrO>mG!E(3+5-LGR}K5sUpzO}BE=w1A5[Yx[<!
    BEek6w,_RGnOul5aARej,~];Xr\o!z=?O{<3UysU{5+7xxD;3$aAA^\-=KA,G[TYX]wTAB,IUU-^
    QA[ZgL0_*W=UIXv~-$*a*-w^xvpa^DWlaH5aR^ATek{A=^RIn5{yc-T$VhUT;[R-Cl_@rG(C2[j(
    JEk!KU*Ep1vz7x;r4bojxrxsB{'oEpz?nOks;HXL.ea;-Lk]sxZ}}%j~Q2s]K}w'Q+=Ya#ElHzY'
    }VBw1xv7R>[erz,3C{XRH-EJBz[\kYJ1=A>=k,>$*EI3_~zuAOI%HpjVo^=Dvp]zij-@6a<*_l,G
    *DvD\a{^X}{}-x_$}=evrs>u5"&Tx;l6YT^]NmB?O|g8T9[=A+E_*H\HeTCYxjO{{T<<BY=Dk{aX
    eeO{<WD1rW:k<1!__R^{pw*3ORKKrm$r+,{hRZKrX=Ax_RaGyk_1pGFB2!plOJ\G2\KRj_RIxD<@
    lGo#>JAllr5=#AorZsv;VYTQ}{^Czx3EE~,1k3p\i3GlC!u;s<5q3EU_GCnK\~j=HR#2l7_K8-sK
    v[iAUG2=\GnpTDJCO5'TQ3'5s)HG7$;>C~b?Ir5a<I=Q$TxCWlWrapaOXo562A7{G!CY^eX^%)3T
    A~kao#|[5W]"bA=K$@E<E>z3@ChBV~>H\e~-DW-iwH>VzavxDYk*{aTo{@AVoBv~_k[8oGe{GimW
    wXH\KG!vM*p@^le=ulKj7bdVIriBmX3:pQoK*U7?p'<H1\x]casY}[?$7lCkUz3DIp1p=X}~{~wR
    I=\+HEvH3{rI7Q*JKT$Z7x-[^mY>Efe__kwU!I,an>e^aKG\jUB-eV,Bmpj;';8./6fc.uvZO@xz
    =1>\e'Ws_oiQkWr3<,^#QC;onfEa$e%'>D<omnGBX_EOZ*RQRW-Y7z*mn[Rkp}p5a!'=3X_O2m7X
    aDVvK@!}pQD3{n=nxa$*~Z36;lIrH=s>ru-Q_m1~1@U>*?@BF^3-7>Ouv7[D;EB>3bPHXH#,3{3#
    [{}WO;l]_,]a*j@$CWo)[>noBE~'[>QJ~<mp~xXTUD!D=pOpT\Z5!_e1F=U^[Ie;;iU'[1TuXEEo
    rl]Uje,\ZqOjOr5-2Tk}n7Pl}-kATB<6j<=Oq6G5U54l2W3U^sH3I?YHQ@AY^zO,e5n!jw;z$YB_
    }=G]T>XsXR,wA~!+r<#jJ=}2w*Ot3]]epJG^vA{es{Y]V)xQpDs#eu^Z=O?x=\^rYR<$k]Cm^XDm
    'mWwom-,)'z!C,>*>^~1p*A[O\CE@=o?OZw!k\:IIHxEV,IUo~Oc\DjI]5!*Hx-wx3_>#D-o=^+C
    Tas$fXpwAu,,TiCm!vi@Y'GJGKs\K#5oeeximtCs'Eu,*espkUr3n'E#lp[1u#v]@I^T->'Y7u;s
    e>D-JHp#]Wjr-lCCD]G5o*h?\AA;1zrQx@>R,vz;5!27!eRleK~AaW@cTaOTe?[s(D{!#UY}!+_E
    RV+,v_>*3Q*vE"<}<WW<G1}UO1:"VWTw}]}TYD'3ae=$$'D!RU,uG1lY;Coo]$A;oU<x{-$QTTTE
    Q3z@0D+Yn2x}@9G<>3B$$T8GImA=O+u\\e;O&oUK>L(@Ho{cII"BR}V,\CuiBn<NIG=T$O-A}xrX
    la}B[$oOAvH2H>$i;{-^OmHz5RurUYD*N^V}s,p=iiC'DoA3uI=?[;Bu^s2zTEj^>V;jTox{,V'V
    vq^jD#+al-\n~w,7~}1%~o<3G^,5YI2JlsjOIu]]QCw=j$<VOTu*E7^[2RVr'-s#Dev;Gx27Ur]-
    OTn^TDZ_E[;$<E$psoUIBiC}^ru]"TQJ^b<swRr+IOW-KICu}XJsmKym+W*8j$i$2wT1=oH]{.GG
    xBwa;rAYu]i{Y?QRq]YXEzJQYO#>uzK^D[el{cIDlX=wRDQfJlKB,$B\6'7IwU<u>$"NQCa_N,>o
    zvZ1>KXwm?'C;DXD?y\Usjmo?*sjQ!fx4EVZs'^$e5?D[U*zi'm]j&{QBn)]A>5=q_T*V'Xrl7kB
    BeM_Q@Gdn$ois#'-ar?ZII!se>IRUU[$GzGJEeR+O+G?SnsRo\\i2Kek?+>m{C2K#!lZ@3X-Cz<j
    [x!-mxBQOs*O](#R]r'5@=';WOCunKu$-7<-QZzwQ*-_?'M=D-+z[Xuw,D#nXw,|9nXVGfy?p,xj
    vQaQG[1mT,e'lo=[1n{On@oU_=DzJpJVp?rWw[QVG#K|wlo>IsVUnvZ3EUO_*7+U}Iu*el5uj~Ux
    I#{B$7A-I$roKwo<]a!;DI<!/;a'w#xu#wE#za>>e$iAe2U5@DjW7B\HTvA2{>UEsx*r'e?{2;Ye
    ^=GO~@5m''uUsV7iKS2Bw]$Y=jI!5]k--?B}B{Uz2{m+s3^Y'V-'[[Ul$}{{oaQ6zW'i>_*roxlA
    $Q<EIOWe#\3<TOsxGCju]WuZ(U=RX?C?{>}^HADl[jmRj~7R3^2=jxkZjLa+nToe5+JY#rU\QjwV
    @kI'v{>\]@feHBuH$\?,i37avk\z?{s,+Dm[*Q1B]~rW,J*x+YETaU*<O!EEQGs}l^{${oo:{oD!
    xp-1_+U}~t'^en$Z5eyW*<v#o^KnC<1AOXJ-Ie@xW'xeCwj4/EmTjgv^DBi]zE}EnXJOE,Cx$;2U
    jo5oE\>[uoVX>2'bBQ\pyoXl2Q5iX1e5$x~nr}sZRI^5}dxP72<T)OOIo:U$]X+s2YROkn{piVNW
    IDsaGwzHYx,~TzkLqJDwQJ}?Z{*ps>rEv\@2YL\O#E&zjE[lJ+<he!]z;*~WJYC;5]+5GXonEH=A
    !IZp3H-J-,Rpl#Uj<]H~uACYz{D{zv2{J1$I!z/m>KAGDl?RaluG{-eV-jZ[[@IjJn\*H@wP?n1I
    $xwQTYunkV2~972=p}eGj$+KI"^#U<1}Qx+ejBpamVn7=TUTD$\2WR#V=;j+~'M+Yjloae7gnrJO
    =;pRx>*X7WnGeT'7IVr+?>V?fb'_e3;>7RIZ2<Rb*zOISG2@ZmHuI*YWrxlXGehME3*la1o[Eu=}
    VT{k0J]^3uV5\z!u{lI{3l-C*[^JJ>HI^^~liv[Jar&^_r'zm2J42rp_;]?-OH-AEsa{7=1ns]m5
    ^A=KRGO[OY?1$BlI1K^$n}x}pjvEq!\*_[={\xIkCCB'~A+Qv75*wo5D?W|7DX_WjpuV*#v"jPhp
    Z{<w*{@KxTj;^{#eI1Y$zEr,l!WVZ1mtL&bo~*b?VG^lKx;'J*u\Yz[9E!Il#s+^:-_z'Im;zDU<
    l}juuH{n]]@u;U1k7xUxXR;Gz-5IHi}>xJoWr)e7K@uQW=z4v^~O7urr9QZ-R,#Y@|fTTz]\R~@D
    27\gw+!al@,XZnjp_K~o(\7!$ooj$2]*!>+D]*AG?OuEr}na;A17o_CBVix!X3{a33aD#nx2>sC;
    X}Amv>s_\"8pm,W<Cp{5'KH[l^151oCiQu;+D$aU\lkkaK,pCWxvTDx*6N<x?Ui_J-VU1*s{\}Sx
    Q}?!C]RTXu?n=}@!sU,W>Zu>}*o'K<[|p[,J@]#=s\-K7u=1Q>^RHYIi=-C;vk]+1Qk<RH!3E3w_
    KaD+2aB{m5vwGuRmV1rA,iZ@6[vJV}emG51=J^@H-~DV!psRiarzIg/AwU1kI*}RCl;5o#GXOn$-
    (vB<IE\33x\uE,3=<Hw1>wAAJOCZEB1UQQ,3p[?KJSE77V\C>7?R\-r-lj+C}C:K>pD6z[,2*UW]
    oK+*=45Us@\os#=k7<;n+v}Aa
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#r0\a'$I\sXoeKTx>H;$w'azo;Y=\okHo#uo;$[I2GH'GZOjxl2G?VC'+A]g;wz}'\8*mB7w
    Y@J<CXTzGC[EfkQ'Be-e]iXa[zx^QI}VCXvE=Iz<DNW}#zY3IAoLCkH5|e-XZ<{JGTooxdl%$I{7
    l@~}\xM}ze}siC[*D;[G@ZvF=7xK7zk^vI]-pKW_CanOI]<ZH^p}6Ro2Q;<$W1DVBuvJB]W3$U]<
    B$-ull>bbmAlA<+rngIC3al!=sB]rrN7Z^~coxzUx}'sQ=ujQ@{v''pT)B\zmi]soVpUWmzxsi,K
    a!'wOmHxV@a>1T}_X!UBpxUK=<=?77X^E9l'-Ox;Y~+pA,lp\RwzHnsECT*3mWN5<u3x2^+a-+HP
    ?w+V=VHEz$zn*#7Am1seDuHr>aEj{+w@/8K[VB';>T*'zRR3o{\7#Yq<soaj]ja]kX7Ur1^;T1O_
    ,'r~$T#e#}O:)I\!u+]wumruI$x2VMue-J+\wRCR-X3TpDB!3{ZQ~I5XT}1+Uvpk12XN^s1{?w]K
    WIK'v^YQG-!>p3p_7}zA8Y@eQ]7UTr~D*!HDEsEjxMO1;!H5I?{'HsZ[pKB5xBG*vo]p2vkDR\n7
    YX[O}O$mJ*=,rJMk]ps|aRx52Epjvpj$^W;V8lp\DjQw+Zau@O]W@eesicm-vClXr;YK[?wt7!++
    KsUU;$7\}B~lB-1p[<AD++]@Awuxa]>IxRVW&/eTxBsD{$x\o$Q!o7p!zm>[I!nwZ7kD]7F=Oe;H
    VCelsC=}{RYs{rjLQrar^pae,i@o={2$=Dv\,w2xx];'[_J7_erzdwVO}>''-Lq77QoDzpV]+ar_
    rY\~D{srwT1"^?oDZ[BHspG~Vz7+I'YploQn8/XAj~DK~sQA!nTaAR;wW3>X<*_M3,z1s5eYr-,$
    pu\[o1eO*2VG)!={'[#aX4%1Q#YurJl"kTC@Bu;jImn1aI$@eZj{t__e<7u$-H*^'^{+1qo#}GDp
    ?mJoeWi{a$}zmVKR*-T>O7GpE,ZGKJjB!1EkV?;o*@+nIH[nJp<Gi;)0Y!Ur+\?H$s[z!^EvpA'v
    (TYnWAA7}vR]+|#><@x!5p@GGG>]DY$eTE6C'K'<R1w7d]'ij-E]Oe$$2|x\CXD>$1r]5UEQkRn'
    -p]~~z\7G,lumm.<XTCd^RDJuvO2g5eWwU15YN3XlHQw<T'lGkW+HVbe#}2B<QZYi>^_]YC<'<vs
    K1>_kauz7DJ7!OBz*a{%svYR=Jx?)EPX_Xpb~Rxp5>m>.=m5>?I,xv<Xm6A\@3AzjKb/9lvV}5BD
    n'm1J3-HrG>{XYzV=1B7kokjKa^G!J7JJVu>'^__U=D}V3E!n~[nr'v+D7oaE(I*k]!'iv^[n]$C
    CY+E{,z'\CdaG<AZVWYDG-}wsVOwj\;xJup|;1WoB,sBIa^eAs#k1&p7BEj_O[MWei_%XYwKnweO
    s#$ACu2].QaWA5z-><oo@]rHY~wYz0C=Xavj!<+AGm0x}$J,uT@:[7VjA_\[^}X{2V?we--#K{^e
    Y<{BAR[}n{O>!v?>c[!*Yrop2T5-K!}_s[W57pr'^R'X!exjW3,Q7nR>5Z7,]krr3*YlsjDCEElW
    !s>1!-+VO4^1WE>rme*EI~w7~HQ!TApOn^X{Ka2=$\cQQA]G=G={=D'\\5<Bwl~:lD?z'RI'BKpr
    x}${OaX^GZ-_1#H<AUIG$_R@?$x-eVa~}U;H2xsEws>G_]TCsnQ{1}>23_Y#5={^#j@u=rkz>l~k
    YKT17*V~X]_*mG-B>1{*FnGC\4Ixw3VIjuQe[QTD5B%s?5W]R{1kRD+E13x}I@o%1ep}k5iD\e{v
    K\2W=$vT_YC}>Cz#_QY>$#+*1ACY,XW[p3Ux3s*Z*5WV9>}sQMi'-2e_A3p;]=<e^'hi-w*J_<Q^
    xkAKGA}EX=eK*k]sv2p]}QW~^C<vE7},]J;nj,5seOuUx5RI]1n~R7>VQ2RAj{AR;uVCU5mI2Y3u
    v'G=H-2'Z<BTV*ur{z}UrEeoasD{C5o2VI'#NYW{an7;U_\JK\aEiCTe!zYj1rDCuGk*?u\*2>5{
    Ido$Opr@o=v,iz{rn+*uRXo[?+(P{oV5>-\>i5+A)XwEUZ[pwym,EQU=_7e;Bol_z]DjCIs!77)s
    Q$xa<'[y2_-@SXUXE5x^jo@DoU{*ZQp2@=mXjDvO+>jvUG$=vXRv<wsIW.xw*Yvka'!suoco23#n
    x+mGUDpna2H;H,)@z2B_s!Zp'z#<}Xr1j=os_~DrDpis7kjn5AnG*3'CA}[A\j}s<=73I5IEJnY5
    u<X#IA+5_HTI={mOUa!J>7Z@$D*OaJkYRkU7_rC!x>$Us}vZ,JZ+lR@G+xzR3aXQ*X7<5eK%UBA]
    4Q{-ED\;DqfS<[EG*i+I[**eO]v{Z<A@'-CE++Y!1a[*I'zu]rO}\[2]@BVYoek'<<!z7~jl1G;>
    BxH,p5xu1WGaw{XY\{w[jIVo7$[[K}]jmXZj!1J+}u>OkwB,dA^C<<<jRYD@lFmv+EXYZ^T[^{*T
    !~Xn[{CCrT0Y3J:OBpi'E_$3se1rJH[Ebo'UU_$QRE}#$2]CB-'2$a*z@R?!Q=Z!+-=5R;TIJg#1
    {w3TU#vYUU7m>nvWEv8$i<Kzm[='Za^W+v>kQ{[9mRH-L-UOl]@z^rn*@5z@<B\K?yk{K?QK!kAX
    $,Cw_xMx]UGHl$\[#2AI,ET=7<aj1n7o]-\\ITZk'a']vk]@H,{B?Vx]QA@1vlu5@+Op^@,L1~;<
    BAmsEviz=kOn_3=XyUE-R@N?AGZp!-~k,e_JUA'*}!aJ[<o=inJKXwWZE=C@a~<r{ps#>n'p,zll
    f7k=enjX[Q11X?xXx,T7pUwJmy9{B1xW}p}oOp}R?u>kC_1T5H]'>_xoA!Ily]HAuOaZ}xQG^=*'
    7%}UHu{[iuv'TI9AEV}='+M}>*uTQzu72\r1>$G=e&/]Ka1JrX[K,#2!Q~sO2Jo--,E5\X{f1T^K
    I]]5@=T{KU_l!5*\mRe7'Xn{Q<Izl=Aj$pTpd9_2-#'<\Oi=xzH1la@azl@TA3-o?x^>*u*J5a|U
    }Y+@s-jI7Q\qkDju7VAZ~+XB1IWUe{^u[=\@!T3WB7T3LmjRCW+_ohw'eTI]n,=i=+AxJ>UE~oM1
    >@OxqyfC,CICHn#52W!~]?!5+@EU5XJQk_k'rI]o,olvPWE^Ow*n^L(Q7'sk5>!_xuxg>+*}[EjE
    YGk~US2<T7?=^+IW==1[Q5~D-QW\Y]w[,1GT@?r#Q{sA'}<[GH\<W>Px!E-XI^^,,$RGaB{x2$,K
    _{W@ajf#1JJZaj$r{vrzUo5Civnr\s]flW*JV\wX,}ls2HQ1#^X5YU\UjWjJT6]-BAG}<Xo~D1C=
    >72jpBx!=*l$2wvwYDTYA5q7jk\"xK2xx;Y7}zG-xaY23REX2'^k{O3C}es_G?7a*?I#_<5ms}~1
    KUx!~\7kAvDTM{Yl{j^+AKTvVID$zpVxe1XYwEO?R'o^Auo]oE]=]lma*7QXYGKv\+$BV\v1zs1p
    _$HBaMnXwR*ViBUr?DeY]ja+!@7iErc^wT#l[2>QK,3KX~nC;U*_{sA~zYsqI4nn1Z\5JwZ7io[K
    E){=i{Ro#Al^;e'3eVi*HjbHo1^nova1C5iWY<mB1xuk_j=V-,?J7D'g\Z{rC5zJ8n\&}Ko\-}XU
    IvmrmBRsem7_#QmRBH~@3z-3toIO\Zlz]T'COA$viL1x@A2DET!^+ni=T')y[W}}(~N>e!{aGmow
    Em7-wClV]KINC=5UpKR7:5uOxK{[nXl13DV^~5{,?>B^pV*R</\s*^AYa3B0|\Z-Tws5zQOWZf=k
    \Abi{5A[1@;5K>u,=A>s|;lx2?X!RUD7Y0@w*!,;VY)X5[A#w}81EBmN\D'rGEDIa[{]!7Zvi1v#
    *x^5+=[^E]#v5T!BCi@v(IGVGxz<>Po;jv@xjvzTQ-'E@z'IY{E*l\p^}T<-nCWj^k1pAoJTK]7D
    $!V,V,QCn>#sVVzG3\+'>1l1Kl]ee1qAQYWGY#1m=Az3OulVRRjL"'_7n]O^^2\zO<O^x+$'@$<1
    k=We??w^p3'1zjrE^rDzv_vXJz[$krv!weOo3[r*7lk1_aIBWl^O5=r+[GssjYH3e#nfhBK-*<B>
    @f$!_^rOV\h;7QClTUeIou(HV~zG!u-z!}DmAxJ'^1O:kzDi4LI!{u*me^y~>pAC$E^M?A^sK7;u
    vjzrHaD3U{jxOnInJ>U];G}x^Rr2awj'wae[E*ZkWR-C!Qx,J_\#;{J7%zE;]3z-3/\1'1U\@3p^
    k<pvalRYlY{$u+~+I@ziWwow}_R<JU@UZa>]p^hoe#BYQ^;BD-vHRY$ws,Gn[[[JB^#=Wrj]<~C?
    {li+ID;xQDTQ?Q3^-I<tO8T]TR_xv7WHE'j7ZCoVlIO!}[_==V[$Ju$Y[=|\N;eT@tCV^5E'BHj,
    ?<x!*Iro]oEC+O=KXJ6I?2HH-Cr[}#VH=-nK]pXBzk*;jX2w,-<~[jI?},;[${D5~x5zE,ex7J1h
    ;Dpi+ED]XIU#DO2ZOzkn7sps.*{nRpB~O1aBz~GE{nEIZ[7?n1kOxXI>zCujIAC{QTY6ZGium**G
    ,xkR}j$<e^nmiUI<eiJK7O}ew-j<x]oV^rm5@UoT)ovHD)'<'_+^,+Y=_BQ@[Dc)6w-Ujp7D{>VC
    X[GrvKG=CjE{r,XJ+R_e*Iu2A(U=QA5ZJz3$sl,si#Qp<ky@\e73OB!ER+{WQ,r<vi{=}k[!+sn,
    -Uk
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#77A^,DWaw^={*iE+TR*2O;^wQZB=*QnB7~YQ$r#a5jYrDe\*5lBxa_aTCD?a7V$T*CEAy>j
    ^*AUO<<'k$_rPlwJ#*+[[o_n=['CW!Ul$HUl}5Qx^,z#\E-aKo>a_([Z@36x5<o^$k\TUw<ol\@,
    mQ7+$k7&a'}'7<X$GeQ]I1{$CAR=wY<])i>mD677;?J[I@_,Hx]i+=xE;J!xGED\i5RKR5OVr*o@
    gq=!m11>^WDsXnvD}BZ_1T[~r~D}Z{'o[XzH-Q73AJ\^k,_1k2x;$,Y%Yl1iGp2B*$32$sX<F()l
    j!x~_^7-p#VnekK^T!,1T~?,AOKKUGIW<{'I~7'=W+kznO{z,+O-[p$JGw-i^k$t{-$[OjBi6zOu
    vpa]w/#5;BCDezAIX24rQreRI~Z(wwAZj7Z*\;!TCo7O#5G=ZH\~Q,z{WzlD3^Y[*=I?,]jB0[xw
    +NM$-G_'Tx;G$Vl,U_X[-EHz2v$K,^$n[XY'vvDG_<uk'\Ozv\CpEI@TYuU${+B[XpZ^nZY3'W]o
    mG~+1*IpG5=>jeshUjD_BC3[K*pDTph\i,~;Y}*lzODK{w'Px:vL\@5*\jR-Y;,*p>X5jx>Wme-B
    FeU;JGwT^B^{3pZrJU7}J;7Z#2nK=vkA+j7@^7Z_K=@7Ku[*K]{wwlr31I3~V*@XRC~<s}G@nBY5
    J\r[p7s5KC@Qss+^we32,*xKBlKe}%X}a^%n^!#T'B\Px-Bo=CiuTR{ZX{HR}wa!qx^[\OH$!H$n
    v*n]C6x#',m[rzUYx*v;$#NvURlQ+v@@<<,StUXTDV=}DVm]CH*V{GRVpVUTwv3VHl2\uW,l$]Ws
    CUlQaj]]-W_Y,^\DlvVxnGT+}IKI,=GJ\u<7}*WDx!nx>lw\^h2TA#7nxA+[X,J_mRka]GIu3DlI
    =-5<D@QCzBKnJ3W^*pOG->!5Q*oTAJoY?Ca\KuKl~-ODiX!wnEb[>slqn<-5iOUxlJ2vIU@'pY{C
    epvu'R1EV^J<mp<>v,\,TCOp.JR,3[~Q>B^A]2C+Dis;X~5wk<s-Z>ViJ-^!Ep'~D?\GD[wlm5?$
    pps]w_OT~DeTRC#v!CnXZe!am]J7RY,DVHC,p3\jadO_~W*7ezHQm+~lRp*v{T>j+u2'G1Dj!=Dw
    AkYH]O"x>^pCVYI\eu=TXu{,IXkIXo<ICQ[ez1x(h---_IYEDW1p},Da5o+V<BDUD3zo?jU3Kw<B
    <O7{KyHOszL5T2v!^nnem{'7!am^aD_?C[JVouO;B!Kkx!l}]Tx^Rn[_OVRQQ-UC\r,UevZVYIn2
    <v=>E^;rD5C&Lfp[+U7TYn1eRlwO'WHjuo-*\Kr{YE~XwCsoB=-Iru35k5VmpJOVOsApZ^"TX7ux
    ;wEFYuj12sYKoWXAKrZ[)AVaEjs{C
`endprotected
//pragma protect end


//pragma protect
//pragma protect begin
`protected

    MTI!#mA;\~I$5?VpUR1p~jo'W3<!mV$B!1+A}=mQV+h5i'RO?YGaor{\u@oIiY[F_ue$TUZ<6a'G
    +Q-OKN}mBz77?@}aJ35/o_n=['CW!Ul$HUlIH-BAIz#^^BU7B!$#m|2|yE@}E=&BF;,!H<}?Tp#C
    '=Zlkt6&Y-u{-=OPp2vW$Gk,LRG}~He<'$}$+i{$^pl{e]\;31#y1\BQ!Cz}s';E^ZRo;+Gr,I{-
    T\$}G>7Joji>L!VV]O."1eC-}j7i/,II3GiV,Bw>OZ]p2k,~!mTCZX\'kV[@;b6H.\xlY.Vnv]&Y
    {u]]$~*iUlnb-_!kW9uroo2rK'YQm!$EG[<X_]EvlYH5=7r'i[xx*VrBV?1{Z^#R}z+eHr^?zpRY
    _k$\Y+*si$yPNiasV'Z<uwv5BCj7vluARB[IEWx1zGRv!jpEUg?YxU*,@$!Xr,Q'u]JrD1Wr5?Ci
    I*Y?KJ^\nr*k;Oxi=GZ-[KIW+x}r=I,!\D98e+;#5WG$:7B!Ky6sOHx^OO5MCr>JE^Bs"[xv>\!}
    =7zI~^B;$mODa5vzC}m3!+*+~4b6n>wHp*>z5mElJp'pD7'pG6O-]xZ,nk1AZCvW]j_2\[j{5++U
    75-r'I$n3~v1IHHHV{rkvE~Xpp}z+{n{xu3+wJ}^GKMKY\VjHoI_zXu5?@jR!'RTr]H[U<*a[5WI
    ,K@[T^#o~pVaUJ#T\spscjvaDH<-#!Y{]Vk>1A-Oe9vUT\COA-T\kGXVeA'+=O-pBJQ1X=z1O\'O
    'zuD'_qd~vJXVR5[KYXJIG@x;jI=Bk<,,^$#zV1v{aOI;Qa2]K-pypGa$;XxBQ3]zj_+;$\;Y6^_
    z;U_I$o-~Wq"[lxQ{,xWW5sB^^JKB\IJXCl,pvlEj@W]]~!7Blja#U[{KRinj>{[;,[H~_5CZxVp
    uou@w1nC,s^3w[a][#QA=kT5NO<@v!\Dik13'{ITlZDBnZLc+CaR9a$kY<+Wxi7n2[WnUxwT=<7u
    ]/nOVOQ5lT^&-}}Y1@CvNuoR#,OA=Dh\-ZK]G$*e$^BI5sDTAxz2^\iooC-=7*~hw<vYC>DQ!{JA
    {$C7Jj-ANb',3OGoIXXH$[7/4@]V[OQGuH,m<zD#B-7T!?<K3$Ix*|9QVsi8m^u@J>1vl'AalXl$
    hGnO*#TpCR+E;Y^V^(BKDH^5${{z7kW&EVwRV~TX<>s3l@G$iUD^#O}K<x*'S+pj$Fl<UxEnx~:k
    aBxQaO}o+W}jG'zz1,3ou<+%k}#[}l3B1mEvL8LA$JX%a7]rDY2=G^E'uDNrf?oxKMZw_;15jAeU
    O]oX[TDnCIpm2ev'D'hjw$J--GH>sUm7llBPpW21R4;n1^(ZI!#^#w_YI2^=J5OHwRmx7ummHxuX
    ekoWer-O[*ZoXXI[#>}5]$XHpiwHel5}IJRZlxChU{A]+I!C(+vpns?@xT,!pD<7YFzMD}]Xe^\[
    $TEVWDsTsn[3]*}rrVO+e@$uXQV+,[-x"$^xZuED<E?]O,'#,]Wxu^#Z2X<-\Hs*OjpCJr=7~;U3
    O^zaa%Kl;,'3,s(V1nssi5;jQHu@<W5RDw@\I^;.1{5xvR@HxDw<HXv3'b57HzqpOlY^a}~EXGuH
    <pHU]T$GN3<zxp#AQElw1UQ#,~\[XVu5kS^!*3I^#UZjsa{XYoEYYZ>vX^SG[^TTEnK=KA}Vi5Az
    1O^0C=@vIBI>J_}!+[{Isx-?5H!O[+$I\_KU(7Qv+IRepiE*nAI2?a<Rm}Qax_w*JPmo!G4#AAkq
    GDO1E?*;E]x-k*YZU8r;vv+j}jEW[z)UIlx?jABz#YJRA;>jHK^o+BieX+l$kumaB^H\3]YV,,B4
    ^K<v+YDu*{7=,?~<Tzm3*7OacxJ<<URZD2DnGX]{uC+V=]*sToG]D!*@;=wA~$!s[3E^QoppCU$w
    @,n'_U],*I?=pxrX{_#~z1r5w,7p^-jlT+BY<EUY3CZIGSIO,Qp+j=BW$!-p22oIex1=E2e]x,@$
    ]om*kxEC[~:E+u;H{xQ}mD]<I?GeQ[~L5CU3<QJ7s_+_-Sna{n\J;n__*DFp>3I!'G?Xe@o.->=Z
    >+l-3<n>OiK2@AYre^A'zDEK@w{U0,+HJAnEWAGXv3[+3uV=$OmQV5GXXuaZ?2ow\2ee5\PRZ$at
    '_V]!Qj#\OjGe'[JV<l}j>7l5T'}[o?X*_Ka@_umUxozRX@]>7w7OH~;E^{5_7-B!hvpR~3G,+~>
    ]A93GxV5~RRG?CwC!_oW^GI]-l<o/K$?v}O5p=~\5O!-uIDuuHji2$;I+xUtlK@YeOJ>PZY[a;X@
    xEz1u3vxGv7kk=,o#u]$uJIV#z*X;;+z*#Tp3TA[a$>CzKU-?^Vu<5B'GMWs>[^eIxie0}2$v]^7
    n5]?{;BnnC7<*jo~]u*j=65@EJ7[DIKYT@5OJEsYp!H<KzvW[rMw5-]V?ZCkO*_<'<r7[zkxH2s\
    m]wBQ-rao@'<T2-W'e*vYBVpBE2$J3]$Q=rtTsWeQ\#]IG_lBo[T';ao<pa3}-=]Uau[1T2*<<{z
    [;!]O;1\jC^z$5'i,K_CYp\u7;lW7DA-8[GIjDCk\$3K?o+za\8aVnzbRa$~*,VY[E~3kEJEps'~
    '+{U>R7=;lYZm-R^r2_QQOm71;!j8ZUDR};l+}_OD,WGsC_ZWGweEo'zOXY7Gor~7Q-wos>V!|v{
    lX?$ur3$=J'#!Q2UAKQoA?~A^YV#Gze>H,l'sIDAZj,a7QsjV[yI>lxz<-DOm$[{x,^BvH~7ezzD
    3ZE5VHswTV^GJZZDOA<C7]]]?Mq}LsR<!H5ruz}+_^FvZe@1x2<1<Jz+{[7[BZ~BQl@cOY{+1{UD
    r@$U_l7=^?$*IQoH^v<^rvQp>5oU*v@1uOHHBi1nxaXo3-jJ$E^x#QsD}G\kE{m#t3C]}1m-zpj=
    #seEBx?@a2,?!Xa@sX{sJG3s2$CX+$spuE!>+,zQupZ-zvas2jApR3TJ+kxTGSp5>5p1Or;{l\xk
    Jn=W*\\limxsKR-wCmSwC[k$5s7$VVAx!ne*IoAx'R]qbDw=}.tQAVe<]^~Q=@z!Tmu~=!5|kLYO
    YDZY*=nxKR"$i'R3_]$B[
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#Y9sH$>S;wIl;_va.C>BOGVD-5+]O-s[iFLoFP119VzJa<,R~J*~r5{+7-r$u-<2}raWVR?W
    O4X[+2U{){Ck;G$k\s{ErsSKwJUz^;}K7VulGGXC{{>oYT=a<eGY~I{,r?!pe1oD+~Jc15WQ(\3j
    a|WIpqXwliF'*ms1*A^G5,aZ**T2<I[[aH-YEsYVQ\]g,&c!YIi^2Ro\sV^7+O<}AOIB;$\h!{zW
    'ZUojG?-$KB-:>rGCQ=@K#nR2CWpoHUJx#^WEH1D>u<Ao\=J?<_i$Rjnur17rw}EampCsExnaYrJ
    Zv-Oz*Ul*W$Us}^+rO-n'y&SI@;mCJmkaEC5EXr[G'nQ}Q=UEoe~>sv=?+3mCa-_I:Q$<[p<>l#C
    Ebg}zH$|C13#oK2,W-s3C5#'X[E}\,^l^+[?pN1,#$=Z>DxjT]&-o<G5*jK2^}$-oVJ-'ixmeW!+
    Hr3\w-A}D_E7+_{?Aj'1G{KRBpr+H;C\kQ!V?Y5Q|,72e\a5nUoT]X\_@p*E;G+OA{+;@Om4QRa>
    T$GpuNOp\]a=@rZEGE\SfE!\5Iz#zErJx<xV7uT1=FYj1E&Mda<uY#Xv?U-2~I[#>uTjZ{j^@6![
    {DG*~E$\}7+}Hz:r?1~U+5#<*wJ[\a,W<>YE<--#wAn?A!BMf4E1sTj{\wUYn7@aZX~*I$^B'I#>
    EiUX~kI,w1o'zIdxH<Jx#7Epa$pG{>YLZIE1B<A?$Y5z\s*$V2x~,j*An[V*z~;IZxlADXEGBQo]
    YmpCAaVxEe_v7ox{1?WajB\V>oZZGXZz,]<Du5k]ut"kYi*9:H,krn<u#[3w!_k-w_=21vZJ@z[n
    <KI}352s>f!\75PE_XG-RR!C@m~aeO+KVJsB#pe>T']VA+Zzv<CQ1Er.x';'}D+m}V<;Qzzi]Bp{
    1}<vk1Q;C;r>C_k<JTTa^T_Qs_jCNOLxoRi^E=!'$a~{_m77XTa-A1J^[55Nu7J!/XaJvY_mW]iZ
    ;}_so?1*v1JAGO_AOlZx\j}Zn7~l^6I,}ZP*}Y'xo\wWH1lyUG\YP$#}#pRY>I%]zQiGW}WNYG??
    B>'O<5irhTCn@@$i
`endprotected
//pragma protect end


`timescale 1 ns / 1 ns
//pragma protect
//pragma protect begin
`protected

    MTI!#xDUDeevWB;]mo~KAv@\,OQIwHeJlv}G3|Q~\+|(vGWDD1zQ5H[$>>5'vy*D]Os@Bi|S!Y2K
    >XxuC|z3C[EfkQ'Be-e]iXa[zx^QI}VCXvEQV_}QNKzaXQ1H_*rWT5j#[E?Xj}H[->5vn'Bno7A{
    QI~zQY!TEO?AOse1+V_l}XT_uBKm7xmzk=a1*jw]1BzHz}CVrHnI<ow-[*eBe$sQOYpA^Cu][k7Y
    V[i~?E+w*~C*Ha-DuA1W~[J[i9KY7Eq1_1kK,-vJB5^AUOq]*\a#CBIx$5kB_1o@xs1zv#J#G-2B
    J'#D\]i%IQi-D{zYa$6ioG{7_A-H5YuIiXkg?*osBQxO3_o>2]#3-+rX+GY7>5!~I8W}@zv=<,^-
    7{Je@T;n@#MiC,zG*!W-Qx#=,k~#aX_ZXzrkCd5EJ}Rvi2Q^1HW]K{v#m@\GQ2\C=!GJpREuQ@B,
    aa]GekluWnv*G-U,VA[!7CIXT}U[BOIE!2.zVx_Bs,Y[+Y1,VKeC2AOViVuYB;\ZAml]Gsi?OoiY
    zJ2Vso';^-Qp,3UUO=}\Kv$@OXHoI*mI-\JJ]#mUH7pW=lG"DG$Wx=v__E5vlirUS==[p)zp}mx3
    >~zIW#02E-=28Zewr1n5+pgNYr_o(eRu!Fwa;;OK@Y1H\WarR1$z[zMZ^Up[_mHZwr]3rT}[,s[3
    1pCq'ZaIH5J?Wv!=@]lC\;3G'zlwUToj2esV26Q2AU=m'@EX}m\JjE}3UHlk=[!77{aO#~5$UC]D
    <r\@<!KH,~3DaUBiQ$3]nTUn>^?7U-_k7$Or@o>>rvu7]<{ApoC2+sK1XI}A-!n\}p'nvQ~+\&,,
    xJxP_J,I$P^$\<;5}af*Qn]1*n+Y7ep3\]pY{RA}{X$2|JnGuA}kVvQ[\BoVz]IOlIoQu{Ul~OW\
    Tl?!ki5B-W\j;a'S1*iv~Gz-]5*+Wj[!v2{OwwUXxR@XX=BuYt^{DJB$Q\^eO7@$5#Q=<\/aRxie
    '[O%]IGD#DiH\nU{KO<X8O'E]q_'l#H5Q'$m3TAUQjl~+Iw+e$Vx]p*CQ$XUX1_HU!Yx^[o1@_'B
    nGmz7u%ewl+E_AKj}u3paU,OZ!W5>O_7HK,n]WOAQu#aEJ\,AD5oUX<]_ue1?D3n{2+QXW!2X2jm
    e5p#(sC~*:g3R7i}Ha3f1vRQ2$wpl_UIR{+H}mxi#[=}IT>T5zmvZ^2pOG2W00,?+vBxRR!aR1E$
    <W[zI@Rl<![X1Bi^jI'DT^a}X~#YpsAp+Rx#AJ7@EHHs$U;}KU)=}UDCY]_]O~z~>eEa1ix_,~7>
    l(ew+Bu=kp'mU@;B}poT=?E>*jJ-l@\7?\[]l?zj>;pU>[eBtp,pEI3X{jW'a^A3}|<ROuww1G$B
    AJ^@IUT>@$[2{sG3aC>]RZ5'BTm=#C'$T*G}p{l3@5j2msBXVaVsATjuo@N_YjGHj@#THXv\]HTP
    'OU!=H,nG7,Z{Uc2]uk=D!G!aQ@pRY\^>\ou\G}sp3?,zRI]Y1AnIi$B<DR=p<>HA>X{Tu\q:e5$
    runB-T\U$~<n2KUw[oI!,K<<w1E_XH,uI++T^$\}~:~DX-OZZUk{@2*]PNBB+^r{\A9eI=ou,#<K
    AZ3J{Er'roGs}JrO*>7WerjG+J!ESh6jRExrIT@Qv*Im[GAI>\j-]~w{e1Xo5Yk{eIDBXe]{'KIt
    eOeX/*[V[yR+;1e,Q'[xT]]Z@Ee]oe^<[o3=n\JH_=-__^uEpw^RK^!{TTVe\sOwZxl,Z\3n$*73
    B7$*?XX[er{[QJ%TQ+T7<D$xwu3+&Ws-;+IxIHE#W7$>pvm3oWVA@wAC$_U<^Nn\*#Q_YYy(WaRD
    ~[U^jkJ>\2A3[-E$qr2uZckAe^]KsijKn+D}3k%j!-QQi\VE-12pWEB\^lmW-uo^KwH[3*kCmRvV
    =@2j7nJ'E5I1HnKV}G>~*U3H=#x;B$#8&vk[s;IiT[[k-UG[XZ]!sI{2'9YoVv-}e7DuJ<:BOuH2
    -o!&]Aw/:QVWBv^*VWVOYz/u7n~QEJ3[?a[|x-]!=BiQN'{A*T{s?Ahj-1,\?lmjWZH2,1~s#_o\
    DQ5\qpJGO2$XpJ'>m[;YkE_A,rIk!Vsk@e?r[qzHIA6\AsZJ{IT7B~jZ[Wa0DiE!'U*K@jxuEG>A
    Uw]jkG3KmX1#/em\5<VzG+*UjV-Ksx'*25r*C?*m+;v\\VvUxr?r]YJns^@e{#9en2#1K;Ql;DBo
    ze\^sW{C}_#v{n{}+oAp1YGH=UYWUY@*EA+1^B#B$mrY?E;,Ha\LnojV!x{[+}'=UvxG!A-BAv{x
    isV@-B5Uyq@BUDZUV}Gk-jeU[2$11\s2+sAp7jY--w5A5{bJpHZ]kSo$++Vo7<,{jOH-C$CsA?nl
    l*;w!xb;YDlI}e[KX<'^K[>=x]${$-M>1~1Cm_sI=nA[_CosE>EzsnR,@rI8n+=xRHQH3pExla]O
    #ps5:ZGV$q~^eUJNjv7E0}_n~!nm!gy><o$Hj]?Ox~7Dp*Ce~<U{o{W^YQJs?amTBOxhsR5'15Ak
    -X6Y!'VrEsOpX{-UI,@'[$s7?1ajC{G,UZs'E+{IKJ_zR$JKamD<v>jx{$R}e=J[k=#IiJel~>rQ
    $-QEUOsHDTCI[3YUG}vO(OOCmKC+~L#\Ow#CI~X+C>_3TE;GX<>Ik-WD<+1,+G<'-J3<m$U>nQ~>
    R-*lKO]7*Hg~$U,\E+KIU{2l5-kC<$,=<m5U[A[Kr+Jk,x,IpGv?v7!'VXn*jOuajEX3GX2}_'Kn
    lHurIGYOxKH{RZ'#z#Wi5TIwTa+<Y7YWBZ~e*J[I-n<'CKxcuG>sjC$T7?GUUBDC[OQTIVpDvQlv
    iwTZhlR+HXHCJO1ooj5CzCY+<^W*R:1XnV[QCWmV=KXolCroAzpOv5^Rx<I-G2j}s{k-E-XRu_kp
    o=Tw{~$;~2Y@u?h=oszH-lCl_w$ECC@C*z3Z=Z[}Y<a?A$_Cl[x|u*nV;xXW<'-u*O]rspT_%E<@
    _XV^]QaTm1>AV-q1oT?XH'5!T5m~n^pnv<J<RwZQpp<r[]m{1HkzC2J51T]Z^-_wnR{sACJurVYp
    5@k}Ikj@Ra^4+XY>cPDiop-+ZU[K[EDa3mRrnJ}!*pKI#TBss>U^vlzp;pVOsY-*3l\Q1GAxrBeE
    ?E$p_l~1_K_73o]wejnQs[oRC\}al$dusVe#eH33x[GI;>[CzJ!bQ>_,o^7#~{\}9C2Qw=@mBI[2
    m@5Z!YX@{12p,<UX{-Xj<QWTH=mQp#H*Tepx2QL,u;u\S}x,v3NI{Q,ZX]VNX,}-wD7R1_p\Qx~1
    #e$CD;$'u}w'}isQXs-HoG[JjxjY7vJADDw-e<[JDoAjsjQ@%I!_J&s=i[JsojoZG1D*[I**}El{
    Kp*GEJ11oe\HTI%Iwje\7Kxz5JEu]]}VCV,hVUl]*T>5C:DGnn^\=O;=QTewB+i\=7RKW,l+GHyl
    s-BKD?GZ>A3ZV,W_[X!nj_lu}1~3V=Uz@wZZB]'L@1[x_TpTe?oWz{Y=Ei1l-OX>rjA->O?;]Jm[
    |92,;@lH3^?s'nOnRiH^To^J5zX$Z}QuT?{+{nnGi\1?\p)o\[}^z{<inGDvVWKBC{,GxY{z#$~}
    @}RNnr*YrRZk]uA{}e?J@*^Bw-7]Ma>KI8eEZz,j,>UnD3!r5rczU<^Hx!e#''=brjiT=QX@-C>V
    B;m5_kl-p*E>Ee?'?E[u~>EpZp[u;p~#ijVj773HxEajt='Rx?Y[,@G\{NLxJ]pw[<,V5IQmpOXu
    IOI7xA]]OsYBwruz\}3D@Vo]#vk[7=@jQ3\+ps]5~KHQnO>r7emMov.vB$Z{A,HaEZoTU{aOmb^l
    2!.}$W~ZC,-Y_w-Ok'!asQzpgH<w$Y+C\*;xTwli<Eq$\}s[?3vQO;~]<7'u=RDVWH*b=E']}71'
    +<<35ATQ-zaI[6;*UpWoUJ;]?#q<-x_9,:nIGZxA,{w|7~n*N=?GD2$EnJYH]AauCED;nI2HZ=#Q
    XijT?e,V$tUn~7?+[i,mleYrTT!eo}[>ZKiICe2Q*,2D52lvTs9o_w@l+5RYH=$@G^;HIaIA_*lC
    E!ur-2DXTvr#zJ=]DKJns$pYY^3<n>oc}X~n}Z;+3X]a=X;{vmQW~'5JXUU}A7#'%~UuWG7!uM-T
    j!E@{I'O?]74ZI>[kC7rMY[_!aB<EZE!^:-\H[IJO@oQK[e+XW?lA!B\\3d#$jGjw,3Iio}@nOk[
    ?1Z<VH]P[A1[6xu7]V<,IcE!YAAr_ewnDr[Gmu~Y#;UYYvY7sK#1;u#Xj'+B5#1#B[\>I5+pBXGK
    \TSq2V-3YV*Ta=kUv_H;kr\YVJn~>(Hv}lIa=XDGXJ#[eu5GneV}nk3zY,$><WDp}afRD}'kl<HV
    a-rQ@jk~Dx<U{vRJ{nTza2QSG*2OVu]^Ierv>BvD^nH}eH=?V5]?3OT3[KJ1.1EQW#anRz3K=kTC
    <sl$\J]JnHC}w1\1Bzs-w*ZEev_QDVja{oReRl[ak[T;>*n<p5A~J=ZC-uea3i\#-7AU~p$|O<v=
    @I<o[,k'bAxx>D;oaGITr}7raDXrxGYCr}3Z,$v#@A'->nem]|@{v_a]pZKEi'K-sBWw$sRG?HdU
    G1~U*=+J'LO3[57>]1Oxm!DiY@E']A)sIx>#A;=-ad3OB[25-,!TR~!<_{B>=rZ^u}Ysr{YkXzDC
    W]1JAn*D+;[B*?>}p\jGUm$eRWGBW''^u@K-I!m<2k>a2\]?lW5^swl3zJ]>xWso~DVu$A=Ys^Uo
    ~W=RVp8KTrKKrXAEG#C{=Wu-BaJJz?jF5RDHwwv-A7A^97's>1ljs2jmK3wJoR[L?Y2TOY2_T'^k
    ao[GVj]T_xkX!Y!5}]\D!Yku]ZHVf1kOHRYDQQrKl7XXpHB_AHA{CvxJT,>G}1I\Y:W1$=Q1>HCD
    nD.pa{<mpp!$BGmzEn*J=ae[mXoq[}vl7k<jx![5B7[p--A~>r@\5DuUC'{kS^m_,GE=BBOYRG3A
    m#x]Up^Hp.=_!}H\Uu,C$DX}n7\l_R,a1K~VEU%$x>2J=i;U$>I+ww^=v>XL^{RY>>lBVlm@5O_U
    BrraYBGr?$OTI<~GI[UwK>^Cm-CuY{\v#^rvDK*X@s$3.1DjD?=Clz5]r'o}7Hs\}s;ApI5aW#OZ
    WrklBX<=IU]uA@Y+z%KoslWT_!Jp[#GJG=-s2#R$,Ta'GxpY<u>91G]Vf\DH<\K!31?Jx\a5@tur
    Eu3*UpEe*T7Au}5XU7Q\,?^Ixkxl~k=,OvoW!nv~$B=]eso3G#Un{7,UQA2}?YzZ<5vTnocO!o!-
    \>xe}no$2Y]>oB>C]Z[l2m_mCY]*I*z;>;z!v{oDk>'z~+^krIZT''-!G}vpWD=zE^>$WD-}eZui
    ,\Hz{GrLx;uk*5AZz}v5KO]EaY_=V7#C^i+;\WTGqul~JxQwDaBT@pMD=^']Ts=x[InV_HGu>Vr.
    lsw3-<n;%vWaYoW[B$x3pYwouG2<*1O$jvWZGlU>>*eewH<~jjaZWse^>sr7kFu=EUoXsJ?_!Xjm
    ZRiYsR:iYwu!,,@=UG}l{aDGBG{nCJzmvGHH7ssoV;U}ax}}3s{RQBJ_^']1OO,rU'j'AEjs[H>i
    TlnOkpKEr#UYU5@2pUJDQ},2jE^iTUVu$5_Io5Cz<,DmH~5;'O5D5Z\us$;!^skc}YZnKBxE@zj=
    2E{x[Z}G]UZeKvn!Nuj[QzWwzSIWz?J5SD3UZ}2\ZO5>W0RDrv=X5r[;<RZz,XX={B~wX\DopDAC
    v-\OJHWOr-,cm[A{J}1AQ_$;H>x<&yBx;oiSu'QIRue2EE=]*a@nE5eu]avKD-z[9+Az'eTs\o!z
    {W,,G]J,EH^i@Jj\WQ1U3oaYl{apV4wpB@73\I#\o2Jr]+@>KQ^EYj?5[CjXsCr-okm'Dm'JEJ3>
    nZ]C^sTonzmOD<krY~1*Y>_5*I1&,Gi5lGW=j;CvIn\[H5;]S7u[?;7eRNY<
`endprotected
//pragma protect end


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_top) # (
    parameter FAMILY             = "TRION",       // New Param
    parameter SYNC_CLK           = 0,
    parameter BYPASS_RESET_SYNC  = 0,             // New Param
    parameter SYNC_STAGE         = 2,             // New Param
    parameter MODE               = "STANDARD",
    parameter DEPTH              = 512,           // Reverted (Equivalent to WDATA_DEPTH) 
    parameter DATA_WIDTH         = 32,            // Reverted (Equivalent to WDATA_WIDTH)
    parameter PIPELINE_REG       = 1,             // Reverted (By default is ON)
    parameter OPTIONAL_FLAGS     = 1,             // Reverted
    parameter OUTPUT_REG         = 0,
    parameter PROGRAMMABLE_FULL  = "STATIC_DUAL", // Set to "NONE" if not require this feature
    parameter PROG_FULL_ASSERT   = 27,
    parameter PROG_FULL_NEGATE   = 23,
    parameter PROGRAMMABLE_EMPTY = "STATIC_DUAL", // Set to "NONE" if not require this feature
    parameter PROG_EMPTY_ASSERT  = 5,
    parameter PROG_EMPTY_NEGATE  = 7,
    parameter ALMOST_FLAG        = OPTIONAL_FLAGS,
    parameter HANDSHAKE_FLAG     = OPTIONAL_FLAGS,
    parameter ASYM_WIDTH_RATIO   = 4,
    parameter WADDR_WIDTH        = depth2width(DEPTH),
    parameter RDATA_WIDTH        = rdwidthcompute(ASYM_WIDTH_RATIO,DATA_WIDTH),
    parameter RD_DEPTH           = rddepthcompute(DEPTH,DATA_WIDTH,RDATA_WIDTH),
    parameter RADDR_WIDTH        = depth2width(RD_DEPTH),
    parameter ENDIANESS		 = 0

)(
    input  wire                   a_rst_i,
    input  wire                   a_wr_rst_i,
    input  wire                   a_rd_rst_i,
    input  wire                   clk_i,
    input  wire                   wr_clk_i,
    input  wire                   rd_clk_i,
    input  wire                   wr_en_i,
    input  wire                   rd_en_i,
    input  wire [DATA_WIDTH-1:0]  wdata,
    output wire                   almost_full_o,
    output wire                   prog_full_o,
    output wire                   full_o,
    output wire                   overflow_o,
    output wire                   wr_ack_o,
    output wire [WADDR_WIDTH :0]  datacount_o,
    output wire [WADDR_WIDTH :0]  wr_datacount_o,
    output wire                   empty_o,
    output wire                   almost_empty_o,
    output wire                   prog_empty_o,
    output wire                   underflow_o,
    output wire                   rd_valid_o,
    output wire [RDATA_WIDTH-1:0] rdata,
    output wire [RADDR_WIDTH :0]  rd_datacount_o,
    output wire                   rst_busy
); 

localparam WR_DEPTH      = DEPTH;
localparam WDATA_WIDTH   = DATA_WIDTH;
localparam RAM_MUX_RATIO = (RDATA_WIDTH <= WDATA_WIDTH/32) ? 32 :
                           (RDATA_WIDTH <= WDATA_WIDTH/16) ? 16 :
                           (RDATA_WIDTH <= WDATA_WIDTH/8)  ? 8  :
                           (RDATA_WIDTH <= WDATA_WIDTH/4)  ? 4  :
                           (RDATA_WIDTH <= WDATA_WIDTH/2)  ? 2  :
                           (RDATA_WIDTH <= WDATA_WIDTH)    ? 1  :
                           (RDATA_WIDTH <= WDATA_WIDTH*2)  ? 2  :
                           (RDATA_WIDTH <= WDATA_WIDTH*4)  ? 4  :
                           (RDATA_WIDTH <= WDATA_WIDTH*8)  ? 8  :
                           (RDATA_WIDTH <= WDATA_WIDTH*16) ? 16 : 32;           

wire                   wr_rst_int;
wire                   rd_rst_int;
wire                   wr_en_int;
wire                   rd_en_int;
wire [WADDR_WIDTH-1:0] waddr;
wire [RADDR_WIDTH-1:0] raddr;
wire                   wr_clk_int;
wire                   rd_clk_int;
wire [WADDR_WIDTH :0]  wr_datacount_int;
wire [RADDR_WIDTH :0]  rd_datacount_int;

generate
    if (ASYM_WIDTH_RATIO == 4) begin
        if (SYNC_CLK) begin
            assign wr_clk_int     = clk_i;    
            assign rd_clk_int     = clk_i;
            assign datacount_o    = wr_datacount_int;
            assign wr_datacount_o = 'd0;
            assign rd_datacount_o = 'd0;
        end
        else begin
            assign wr_clk_int     = wr_clk_i;    
            assign rd_clk_int     = rd_clk_i;
            assign datacount_o    = 'd0;
            assign wr_datacount_o = wr_datacount_int;
            assign rd_datacount_o = rd_datacount_int;
        end
    end
    else begin
        assign datacount_o    = 'd0;
        assign wr_datacount_o = wr_datacount_int;
        assign rd_datacount_o = rd_datacount_int;
        if (SYNC_CLK) begin
            assign wr_clk_int     = clk_i;    
            assign rd_clk_int     = clk_i;
        end
        else begin
            assign wr_clk_int     = wr_clk_i;    
            assign rd_clk_int     = rd_clk_i;
        end
    end    

    if (!SYNC_CLK) begin
        (* async_reg = "true" *) reg [1:0] wr_rst;
        (* async_reg = "true" *) reg [1:0] rd_rst;
        
        always @ (posedge wr_clk_int or posedge a_rst_i) begin
            if (a_rst_i) 
                wr_rst <= 2'b11;
            else 
                wr_rst <= {wr_rst[0],1'b0};            
        end
        
        always @ (posedge rd_clk_int or posedge a_rst_i) begin
            if (a_rst_i) 
                rd_rst <= 2'b11;
            else 
                rd_rst <= {rd_rst[0],1'b0};            
        end

        if (BYPASS_RESET_SYNC) begin
            assign wr_rst_int = a_wr_rst_i;
            assign rd_rst_int = a_rd_rst_i; 
            assign rst_busy   = 1'b0;
        end 
        else begin
            assign wr_rst_int = wr_rst[1];
            assign rd_rst_int = rd_rst[1]; 
            assign rst_busy   = wr_rst_int | rd_rst_int;
        end
    end
    else begin
        (* async_reg = "true" *) reg [1:0] a_rst;
        
        always @ (posedge clk_i or posedge a_rst_i) begin
            if (a_rst_i) 
                a_rst <= 2'b11;
            else 
                a_rst <= {a_rst[0],1'b0};            
        end

        if (BYPASS_RESET_SYNC) begin
            assign wr_rst_int = a_rst_i;
            assign rd_rst_int = a_rst_i;
            assign rst_busy   = 1'b0;
        end
        else begin
            assign wr_rst_int = a_rst[1];
            assign rd_rst_int = a_rst[1];   
            assign rst_busy   = wr_rst_int | rd_rst_int;
        end
    end 
endgenerate

`IP_MODULE_NAME(efx_fifo_ram) # (
    .FAMILY        (FAMILY),
    .MODE          (MODE),
    .WR_DEPTH      (WR_DEPTH),
    .RD_DEPTH      (RD_DEPTH),
    .WDATA_WIDTH   (WDATA_WIDTH),
    .RDATA_WIDTH   (RDATA_WIDTH),
    .WADDR_WIDTH   (WADDR_WIDTH),
    .RADDR_WIDTH   (RADDR_WIDTH),
    .OUTPUT_REG    (OUTPUT_REG),
    .RAM_MUX_RATIO (RAM_MUX_RATIO),
    .ENDIANESS	   (ENDIANESS)
) xefx_fifo_ram (
    .wdata (wdata), 
    .waddr (waddr),
    .raddr (raddr), 
    .we    (wr_en_int), 
    .re    (rd_en_int),
    .wclk  (wr_clk_int),
    .rclk  (rd_clk_int),
    .rdata (rdata)
);

`IP_MODULE_NAME(efx_fifo_ctl) # (
    .FAMILY             (FAMILY),
    .SYNC_CLK           (SYNC_CLK),
    .SYNC_STAGE         (SYNC_STAGE),
    .MODE               (MODE),
    .WR_DEPTH           (WR_DEPTH),
    .WADDR_WIDTH        (WADDR_WIDTH),
    .RADDR_WIDTH        (RADDR_WIDTH),
    .ASYM_WIDTH_RATIO   (ASYM_WIDTH_RATIO),
    .RAM_MUX_RATIO      (RAM_MUX_RATIO),
    .PIPELINE_REG       (PIPELINE_REG),
    .ALMOST_FLAG        (ALMOST_FLAG),
    .PROGRAMMABLE_FULL  (PROGRAMMABLE_FULL),
    .PROG_FULL_ASSERT   (PROG_FULL_ASSERT),
    .PROG_FULL_NEGATE   (PROG_FULL_NEGATE),
    .PROGRAMMABLE_EMPTY (PROGRAMMABLE_EMPTY),
    .PROG_EMPTY_ASSERT  (PROG_EMPTY_ASSERT),
    .PROG_EMPTY_NEGATE  (PROG_EMPTY_NEGATE),
    .OUTPUT_REG         (OUTPUT_REG),
    .HANDSHAKE_FLAG     (HANDSHAKE_FLAG)
) xefx_fifo_ctl (
    .wr_rst          (wr_rst_int),
    .rd_rst          (rd_rst_int),
    .wclk            (wr_clk_int),
    .rclk            (rd_clk_int),
    .we              (wr_en_i),
    .re              (rd_en_i),
    .wr_full         (full_o),
    .wr_ack          (wr_ack_o),
    .rd_empty        (empty_o),
    .wr_almost_full  (almost_full_o),
    .rd_almost_empty (almost_empty_o),
    .wr_prog_full    (prog_full_o),
    .rd_prog_empty   (prog_empty_o),
    .wr_en_int       (wr_en_int),
    .rd_en_int       (rd_en_int),
    .waddr           (waddr),
    .raddr           (raddr),
    .wr_datacount    (wr_datacount_int),
    .rd_datacount    (rd_datacount_int),
    .rd_vld          (rd_valid_o),
    .wr_overflow     (overflow_o),
    .rd_underflow    (underflow_o)
);

function integer depth2width;
input [31:0] depth;
begin : fnDepth2Width
    if (depth > 1) begin
        depth = depth - 1;
        for (depth2width=0; depth>0; depth2width = depth2width + 1)
            depth = depth>>1;
        end
    else
    depth2width = 0;
end
endfunction 

function integer width2depth;
input [31:0] width;
begin : fnWidth2Depth
    width2depth = width**2;
end
endfunction

function integer rdwidthcompute;
input [31:0] asym_option;
input [31:0] wr_width;
begin : RdWidthCompute
    rdwidthcompute = (asym_option==0)? wr_width/16 :
                     (asym_option==1)? wr_width/8  :
                     (asym_option==2)? wr_width/4  :
                     (asym_option==3)? wr_width/2  :
                     (asym_option==4)? wr_width/1  :
                     (asym_option==5)? wr_width*2  :
                     (asym_option==6)? wr_width*4  :
                     (asym_option==7)? wr_width*8  :
                     (asym_option==8)? wr_width*16 : wr_width/1;
end
endfunction

function integer rddepthcompute;
input [31:0] wr_depth;
input [31:0] wr_width;
input [31:0] rd_width;
begin : RdDepthCompute
    rddepthcompute = (wr_depth * wr_width) / rd_width;
end
endfunction

endmodule


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_ram) #(
    parameter FAMILY        = "TRION",
    parameter MODE          = "STANDARD",
    parameter WR_DEPTH      = 512,
    parameter RD_DEPTH      = 512,
    parameter WDATA_WIDTH   = 8,
    parameter RDATA_WIDTH   = 8,
    parameter WADDR_WIDTH   = 9,
    parameter RADDR_WIDTH   = 9,
    parameter OUTPUT_REG    = 1,
    parameter RAM_MUX_RATIO = 4,
    parameter ENDIANESS 	= 0 //0: Big endian (default)   1: Little endian 
) (
    input  wire                     wclk,
    input  wire                     rclk,
    input  wire                     we,
    input  wire                     re,
    input  wire [(WDATA_WIDTH-1):0] wdata,
    input  wire [(WADDR_WIDTH-1):0] waddr,
    input  wire [(RADDR_WIDTH-1):0] raddr,
    output wire [(RDATA_WIDTH-1):0] rdata
);

localparam MEM_DEPTH         = (WR_DEPTH > RD_DEPTH) ? WR_DEPTH : RD_DEPTH;
localparam MEM_DATA_WIDTH    = (WDATA_WIDTH > RDATA_WIDTH) ? RDATA_WIDTH : WDATA_WIDTH;   
localparam LSB_WIDTH         = (WADDR_WIDTH > RADDR_WIDTH) ? (WADDR_WIDTH - RADDR_WIDTH) : (RADDR_WIDTH - WADDR_WIDTH);
localparam RDATA_WDATA_RATIO = (RDATA_WIDTH <= WDATA_WIDTH/32) ? "ONE_THIRTYTWO" :
                               (RDATA_WIDTH <= WDATA_WIDTH/16) ? "ONE_SIXTEENTH" :
                               (RDATA_WIDTH <= WDATA_WIDTH/8)  ? "ONE_EIGHTH"    :
                               (RDATA_WIDTH <= WDATA_WIDTH/4)  ? "ONE_FOURTH"    :
                               (RDATA_WIDTH <= WDATA_WIDTH/2)  ? "ONE_HALF"      :
                               (RDATA_WIDTH <= WDATA_WIDTH)    ? "ONE"           :
                               (RDATA_WIDTH <= WDATA_WIDTH*2)  ? "TWO_TIMES"     :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "FOUR_TIMES"    :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "EIGHT_TIMES"   :
                               (RDATA_WIDTH <= WDATA_WIDTH*4)  ? "SIXTEEN_TIMES" : "THIRTYTWO_TIMES";

reg [MEM_DATA_WIDTH-1:0] ram[MEM_DEPTH-1:0];
reg [RDATA_WIDTH-1:0]    r_rdata_1P;
reg [RDATA_WIDTH-1:0]    r_rdata_2P;

wire                     re_int;

generate
    if (FAMILY == "TRION") begin
        if (RDATA_WDATA_RATIO == "ONE") begin
            always @ (posedge wclk) begin
                if (we)
                    ram[waddr] <= wdata;
            end
    
            always @ (posedge rclk) begin
                if (re_int) begin
                    r_rdata_1P <= ram[raddr];
                end
                r_rdata_2P <= r_rdata_1P;
            end
        end
        
        else if (RDATA_WDATA_RATIO == "ONE_THIRTYTWO" || RDATA_WDATA_RATIO == "ONE_SIXTEENTH" || RDATA_WDATA_RATIO == "ONE_EIGHTH" || RDATA_WDATA_RATIO == "ONE_FOURTH"  || RDATA_WDATA_RATIO == "ONE_HALF" ) begin
            if (ENDIANESS == 0) begin 
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
                	for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (we) begin
                            ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                end
                always @ (posedge rclk) begin 
                	if (re_int) begin
                		r_rdata_1P <= ram[raddr];
                    end
                		r_rdata_2P <= r_rdata_1P;
                end
            end
            else begin //endianess == 1
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (we) begin
                            ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                end
                always @ (posedge rclk) begin 
                	if (re_int) begin
                		r_rdata_1P <= ram[raddr];
                	end
                		r_rdata_2P <= r_rdata_1P;
                end
            end
        end
        
        else if (RDATA_WDATA_RATIO == "TWO_TIMES" || RDATA_WDATA_RATIO == "FOUR_TIMES"  || RDATA_WDATA_RATIO == "EIGHT_TIMES"  || RDATA_WDATA_RATIO == "SIXTEEN_TIMES"  ||RDATA_WDATA_RATIO == "THIRTYTWO_TIMES" ) begin
            //integer i;
        	//reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        	if (ENDIANESS == 0) begin
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr; 
        		always @ (posedge rclk) begin
        			for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    	end
                        	r_rdata_2P <= r_rdata_1P;
                    end
                end 
            end
            else begin //endianess == 1
            	always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        		always @ (posedge rclk) begin
        			for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    	end
                        	r_rdata_2P <= r_rdata_1P;
                    end
                end
            end
        end
        if (OUTPUT_REG) begin
            assign re_int = re;
            assign rdata  = r_rdata_2P;            
        end
        else begin
            assign re_int = re;
            assign rdata  = r_rdata_1P;
        end
    end
    else if (FAMILY == "TITANIUM") begin
        if (RDATA_WDATA_RATIO == "ONE") begin
            always @ (posedge wclk) begin
                if (we)
                    ram[waddr] <= wdata;
            end
    
            always @ (posedge rclk) begin
                if (re_int) begin
                    r_rdata_1P <= ram[raddr];
                    r_rdata_2P <= r_rdata_1P;
                end
            end
        end 
        else if (RDATA_WDATA_RATIO == "ONE_THIRTYTWO" || RDATA_WDATA_RATIO == "ONE_SIXTEENTH" || RDATA_WDATA_RATIO == "ONE_EIGHTH" || RDATA_WDATA_RATIO == "ONE_FOURTH"  || RDATA_WDATA_RATIO == "ONE_HALF" ) begin
            //integer i;
            //reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            if (ENDIANESS == 0) begin
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (we) begin
                            	ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                 end
               	always @ (posedge rclk) begin 
               		if (re_int) begin
               			r_rdata_1P <= ram[raddr];
               			r_rdata_2P <= r_rdata_1P;
               		end
               	end
            end
            
            else begin //endianess == 1
            	integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
            	always @ (posedge wclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (we) begin
                            	ram[{waddr,lsbaddr}] <= wdata[((WDATA_WIDTH/RAM_MUX_RATIO)*i) +: WDATA_WIDTH/RAM_MUX_RATIO];
                        end
                    end
                 end
               	always @ (posedge rclk) begin 
               		if (re_int) begin
               			r_rdata_1P <= ram[raddr];
               			r_rdata_2P <= r_rdata_1P;
               		end
               	end
            end
        end
        else if (RDATA_WDATA_RATIO == "TWO_TIMES" || RDATA_WDATA_RATIO == "FOUR_TIMES"  || RDATA_WDATA_RATIO == "EIGHT_TIMES"  || RDATA_WDATA_RATIO == "SIXTEEN_TIMES"  || RDATA_WDATA_RATIO == "THIRTYTWO_TIMES" ) begin
        	//integer i;
            //reg  [LSB_WIDTH-1 :0 ]   lsbaddr;
        	if (ENDIANESS == 0) begin
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
            	reg  [LSB_WIDTH-1 :0 ]   lsbaddr;        
            	always @ (posedge rclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = RAM_MUX_RATIO-1-i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    		r_rdata_2P                                                               <= r_rdata_1P;
                    	end
                    end
                end 
            end
            
            else begin //endianess ==1
        		always @ (posedge wclk) begin
        			if (we)
        				ram[waddr] <= wdata;
        		end
        		integer i;
        		reg  [LSB_WIDTH-1 :0 ]   lsbaddr;        
            	always @ (posedge rclk) begin
            		for (i=0; i<RAM_MUX_RATIO; i=i+1) begin
                    	lsbaddr = i;
                    	if (re_int) begin
                    		r_rdata_1P[((RDATA_WIDTH/RAM_MUX_RATIO)*i) +: RDATA_WIDTH/RAM_MUX_RATIO] <= ram[{raddr,lsbaddr}];
                    		r_rdata_2P                                                               <= r_rdata_1P;
                    	end
                    end
                end 
            end
        end
        if (MODE == "STANDARD") begin     
            if (OUTPUT_REG) begin
                reg re_r;
                always @ (posedge rclk) begin
                    re_r <= re;
                end
                assign re_int = re | re_r;        
                assign rdata  = r_rdata_2P;            
            end
            else begin
                assign re_int = re;
                assign rdata  = r_rdata_1P;
            end
        end
        else begin
            assign re_int = re;
            assign rdata  = r_rdata_1P;
        end        
    end
endgenerate

endmodule

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2021 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   gray2bin.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Gray to Binary Encoding Convertor
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns/1ps

module `IP_MODULE_NAME(efx_fifo_gray2bin)
#(parameter WIDTH=5)
(// outputs
 output wire [WIDTH-1:0] bin_o,
 // input
 input [WIDTH-1:0] gray_i);

//---------------------------------------------------------------------
// Recursive Module
// Description: reduction xor
generate
   if (WIDTH > 1) begin
      wire [1:0] bin_1;
      assign bin_1 = {gray_i[WIDTH-1], gray_i[WIDTH-1]^gray_i[WIDTH-2]};
      if (WIDTH == 2) begin
	 assign bin_o = bin_1;
      end
      else begin
	 assign bin_o[WIDTH-1] = bin_1[1];
	 `IP_MODULE_NAME(efx_fifo_gray2bin) #(.WIDTH(WIDTH-1)) u_gray2bin (.bin_o(bin_o[WIDTH-2:0]), .gray_i({bin_1[0], gray_i[WIDTH-3:0]}));
      end
   end
   else /* if (WIDTH == 1) */
     assign bin_o = gray_i;
endgenerate
   
endmodule 

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   pipe_reg.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Parallel Pipelining Shift Register
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_datasync) #(
    parameter STAGE = 32,
    parameter WIDTH = 4
) (
 input  wire             clk_i,
 input  wire [WIDTH-1:0] d_i,
 output wire [WIDTH-1:0] d_o
);

(* async_reg = "true" *) reg [WIDTH-1:0] pipe_reg [STAGE-1:0];
integer i;

always @(posedge clk_i) begin
  for (i=STAGE-1; i>0; i = i - 1) begin
    pipe_reg[i] <= pipe_reg[i-1];
  end
  pipe_reg[0] <= d_i;
end
assign d_o = pipe_reg[STAGE-1];
   

endmodule

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2021 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   simple_dual_port_ram_fifo.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      EFX FIFO
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
//
// *******************************

module `IP_MODULE_NAME(efx_fifo_ctl) # (
    parameter FAMILY             = "TRION",
    parameter SYNC_CLK           = 1,
    parameter SYNC_STAGE         = 2,
    parameter MODE               = "STANDARD",
    parameter WR_DEPTH           = 512,
    parameter WADDR_WIDTH        = 9,
    parameter RADDR_WIDTH        = 9,
    parameter ASYM_WIDTH_RATIO   = 4,
    parameter RAM_MUX_RATIO      = 1,
    parameter PIPELINE_REG       = 1,
    parameter ALMOST_FLAG        = 1,
    parameter PROGRAMMABLE_FULL  = "NONE",
    parameter PROG_FULL_ASSERT   = 0,
    parameter PROG_FULL_NEGATE   = 0,
    parameter PROGRAMMABLE_EMPTY = "NONE",
    parameter PROG_EMPTY_ASSERT  = 0,
    parameter PROG_EMPTY_NEGATE  = 0,
    parameter OUTPUT_REG         = 0,
    parameter HANDSHAKE_FLAG     = 1
)(
    input   wire                   wr_rst,
    input   wire                   rd_rst,
    input   wire                   wclk,
    input   wire                   rclk,
    input   wire                   we,
    input   wire                   re,
    output  wire                   wr_full,
    output  reg                    wr_ack,
    output  wire                   wr_almost_full,
    output  wire                   rd_empty,
    output  wire                   rd_almost_empty,
    output  wire                   wr_prog_full,
    output  wire                   rd_prog_empty,
    output  wire                   wr_en_int,
    output  wire                   rd_en_int,
    output  wire [WADDR_WIDTH-1:0] waddr,
    output  wire [RADDR_WIDTH-1:0] raddr,
    output  wire [WADDR_WIDTH:0]   wr_datacount,
    output  wire [RADDR_WIDTH:0]   rd_datacount,
    output  wire                   rd_vld,
    output  reg                    wr_overflow,
    output  reg                    rd_underflow
);

reg  [WADDR_WIDTH:0] waddr_cntr;
reg  [RADDR_WIDTH:0] raddr_cntr;
reg  [RADDR_WIDTH:0] raddr_cntr_r;
reg                  rd_valid;

wire [RADDR_WIDTH:0] raddr_cntr_w;
wire [WADDR_WIDTH:0] waddr_int;
wire [RADDR_WIDTH:0] raddr_int;
wire [RADDR_WIDTH:0] raddr_int_dcount;
wire [RADDR_WIDTH:0] raddr_dcount;
wire                 rd_empty_int;
wire [WADDR_WIDTH:0] wr_datacount_int;
wire [RADDR_WIDTH:0] rd_datacount_int;

assign waddr     = waddr_cntr[WADDR_WIDTH-1:0];
assign raddr     = raddr_cntr[RADDR_WIDTH-1:0];
assign wr_en_int = we & ~wr_full;

generate
    if (MODE == "FWFT") begin    
        reg init_set;
        reg rd_empty_fwft;
        assign rd_en_int     = (~rd_empty_int & rd_empty) | (re & ~rd_empty_int);
        assign rd_empty      = rd_empty_fwft;
        assign raddr_cntr_w  = ~rd_empty ? raddr_cntr_r/*raddr_cntr-1*/ : raddr_cntr;
        
        if (ASYM_WIDTH_RATIO < 4) begin
            assign wr_datacount  = wr_datacount_int;
            assign rd_datacount  = rd_empty ? rd_datacount_int : ~init_set ? (rd_datacount_int+1'b1) : rd_datacount_int;
        end
        else begin
            assign wr_datacount  = wr_datacount_int;
            assign rd_datacount  = rd_datacount_int;        
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                init_set <= 1'b1;
            end
            else if (~init_set & rd_empty) begin
                init_set <= 1'b1;            
            end
            else if (~rd_empty_int) begin
                init_set <= 1'b0;            
            end
            else if (rd_empty) begin
                init_set <= 1'b1;            
            end
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_empty_fwft <= 1'b1;
            end
            else if (rd_en_int) begin
                rd_empty_fwft <= 1'b0;            
            end
            else if (re) begin
                rd_empty_fwft <= 1'b1;            
            end
        end          
        
        if (FAMILY == "TRION") begin
            if (OUTPUT_REG) begin
                always @ (posedge rclk or posedge rd_rst) begin
                    if (rd_rst) begin
                        rd_valid <= 1'b0;
                    end
                    else begin
                        rd_valid <= ~rd_empty;
                    end
                end
                assign rd_vld = rd_valid;                
            end    
            else begin
                assign rd_vld = ~rd_empty;                
            end
        end
        else begin
            assign rd_vld = ~rd_empty;
        end
    end
    else begin
        assign rd_en_int     = re & ~rd_empty_int;
        assign rd_empty      = rd_empty_int;
        assign raddr_cntr_w  = raddr_cntr;
        assign wr_datacount  = wr_datacount_int;
        assign rd_datacount  = rd_datacount_int;
        
        if (OUTPUT_REG) begin
            reg rd_valid_r;
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    rd_valid_r <= 'h0;
                    rd_valid   <= 'h0;
                end
                else begin
                    {rd_valid,rd_valid_r} <= {rd_valid_r,rd_en_int};
                end
            end
            assign rd_vld = rd_valid;            
        end
        else begin
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    rd_valid  <= 'h0;
                end
                else begin
                    rd_valid <= rd_en_int;
                end
            end
            assign rd_vld = rd_valid;
        end
    end
    
    if (ALMOST_FLAG) begin
        assign wr_almost_full   = wr_datacount_int >= WR_DEPTH-1;
        assign rd_almost_empty  = rd_datacount_int <= 'd1;  
    end
    else begin
        assign wr_almost_full   = 1'b0;
        assign rd_almost_empty  = 1'b0;        
    end
    
    if (PROGRAMMABLE_FULL == "STATIC_SINGLE") begin
        reg    wr_prog_full_int;
        assign wr_prog_full  = wr_datacount >= PROG_FULL_ASSERT;
        
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_prog_full_int  <= 1'b0;
            end
            else begin
                wr_prog_full_int  <= wr_prog_full;
            end
        end  
    end
    else if (PROGRAMMABLE_FULL == "STATIC_DUAL") begin
        reg    wr_prog_full_int;
        assign wr_prog_full  = wr_prog_full_int ? wr_datacount >= PROG_FULL_NEGATE : wr_datacount >= PROG_FULL_ASSERT;   

        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_prog_full_int  <= 1'b0;
            end
            else begin
                wr_prog_full_int  <= wr_prog_full;
            end
        end              
    end
    else begin
        assign wr_prog_full  = 1'b0; 
    end
        
    if (PROGRAMMABLE_EMPTY == "STATIC_SINGLE") begin
        reg    rd_prog_empty_int;
        assign rd_prog_empty  = rd_datacount <= PROG_EMPTY_ASSERT;
            
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_prog_empty_int <= 1'b1;
            end
            else begin
                rd_prog_empty_int <= rd_prog_empty;
            end
        end
    end
    else if (PROGRAMMABLE_EMPTY == "STATIC_DUAL") begin
        reg    rd_prog_empty_int;
        assign rd_prog_empty = rd_prog_empty_int ? (rd_datacount <= PROG_EMPTY_NEGATE) : (rd_datacount <= PROG_EMPTY_ASSERT);
            
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_prog_empty_int <= 1'b1;
            end
            else begin
                rd_prog_empty_int <= rd_prog_empty;
            end
        end  
    end
    else begin
        assign rd_prog_empty  = 1'b0; 
    end
    
    if (HANDSHAKE_FLAG) begin
    
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_ack <= 1'b0;
            end
            else begin
                wr_ack <= wr_en_int & ~wr_overflow;
            end
        end

        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                wr_overflow <= 1'b0;
            end
            else if (we && wr_full) begin
                wr_overflow <= 1'b1;
            end
            else begin
                wr_overflow <= 1'b0;            
            end
        end
        
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                rd_underflow <= 1'b0;
            end
            else if (re && rd_empty) begin
                rd_underflow <= 1'b1;
            end
            else begin
                rd_underflow <= 1'b0;            
            end
        end
    end
    
    localparam RATIO_WIDTH = (RADDR_WIDTH >= WADDR_WIDTH)? RADDR_WIDTH - WADDR_WIDTH : WADDR_WIDTH - RADDR_WIDTH;
    
    if (ASYM_WIDTH_RATIO < 4) begin
        assign wr_full          = (waddr_cntr[WADDR_WIDTH]^raddr_int[RADDR_WIDTH]) & (waddr_cntr[WADDR_WIDTH-1:0] == raddr_int[RADDR_WIDTH-1:RATIO_WIDTH]);
        assign rd_empty_int     = waddr_int[WADDR_WIDTH:0] == raddr_cntr[RADDR_WIDTH:RATIO_WIDTH];
        assign wr_datacount_int = waddr_cntr - (raddr_int/RAM_MUX_RATIO);
        assign rd_datacount_int = (waddr_int*RAM_MUX_RATIO)-raddr_cntr;
    end
    else begin
        assign wr_full          = (waddr_cntr[WADDR_WIDTH]^raddr_int[RADDR_WIDTH]) & (waddr_cntr[WADDR_WIDTH-1:RATIO_WIDTH] == raddr_int[RADDR_WIDTH-1:0]);
        assign rd_empty_int     = (waddr_int- raddr_cntr*RAM_MUX_RATIO) < RAM_MUX_RATIO;
        assign wr_datacount_int = waddr_cntr - (raddr_int*RAM_MUX_RATIO);
        assign rd_datacount_int = (waddr_int/RAM_MUX_RATIO)-raddr_cntr_w;
    end
endgenerate

always @ (posedge wclk or posedge wr_rst) begin
    if (wr_rst) begin
        waddr_cntr <= 'h0;
    end
    else if (wr_en_int) begin
        waddr_cntr <= waddr_cntr + 1'b1;
    end
end

always @ (posedge rclk or posedge rd_rst) begin
    if (rd_rst) begin
        raddr_cntr   <= 'h0;
        raddr_cntr_r <= 'h0;
    end
    else if (rd_en_int) begin
        raddr_cntr   <= raddr_cntr + 1'b1;
        raddr_cntr_r <= raddr_cntr;
    end
end

generate
    if (SYNC_CLK) begin
        assign waddr_int        = waddr_cntr;
        assign raddr_int        = raddr_cntr_w;
    end
    else begin
        reg  [RADDR_WIDTH:0] raddr_cntr_gry_r;
        reg  [WADDR_WIDTH:0] waddr_cntr_gry_r;
        
        wire [RADDR_WIDTH:0] raddr_cntr_gry;
        wire [RADDR_WIDTH:0] raddr_cntr_gry_sync;
        wire [RADDR_WIDTH:0] raddr_cntr_sync_g2b;
        wire [WADDR_WIDTH:0] waddr_cntr_gry;
        wire [WADDR_WIDTH:0] waddr_cntr_gry_sync;
        wire [WADDR_WIDTH:0] waddr_cntr_sync_g2b;

        if (PIPELINE_REG) begin
            reg  [RADDR_WIDTH:0] raddr_cntr_sync_g2b_r;    
            reg  [WADDR_WIDTH:0] waddr_cntr_sync_g2b_r;        
        
            assign waddr_int        = waddr_cntr_sync_g2b_r;
            assign raddr_int        = raddr_cntr_sync_g2b_r;
            
            always @ (posedge wclk or posedge wr_rst) begin
                if (wr_rst) begin
                    raddr_cntr_sync_g2b_r <= 'h0;
                end
                else begin
                    raddr_cntr_sync_g2b_r <= raddr_cntr_sync_g2b;
                end
            end
            
            always @ (posedge rclk or posedge rd_rst) begin
                if (rd_rst) begin
                    waddr_cntr_sync_g2b_r <= 'h0;
                end
                else begin
                    waddr_cntr_sync_g2b_r <= waddr_cntr_sync_g2b;
                end
            end
        end
        else begin
            assign waddr_int        = waddr_cntr_sync_g2b;
            assign raddr_int        = raddr_cntr_sync_g2b;        
        end
      
        always @ (posedge rclk or posedge rd_rst) begin
            if (rd_rst) begin
                raddr_cntr_gry_r <= 'h0;
            end
            else begin
                raddr_cntr_gry_r <= raddr_cntr_gry;
            end
        end
        `IP_MODULE_NAME(efx_fifo_bin2gray) # (.WIDTH(RADDR_WIDTH+1)                     ) xrd2wr_bin2gray    (.bin_i(raddr_cntr_w), .gray_o(raddr_cntr_gry));
        `IP_MODULE_NAME(efx_fifo_datasync) # (.STAGE(SYNC_STAGE), .WIDTH (RADDR_WIDTH+1)) xrd2wr_addr_sync   (.clk_i(wclk), .d_i(raddr_cntr_gry_r), .d_o(raddr_cntr_gry_sync));
        `IP_MODULE_NAME(efx_fifo_gray2bin) # (.WIDTH(RADDR_WIDTH+1)                     ) xrd2wr_gray2bin    (.gray_i(raddr_cntr_gry_sync), .bin_o(raddr_cntr_sync_g2b));
        
        always @ (posedge wclk or posedge wr_rst) begin
            if (wr_rst) begin
                waddr_cntr_gry_r <= 'h0;
            end
            else begin
                waddr_cntr_gry_r <= waddr_cntr_gry;
            end
        end        
        `IP_MODULE_NAME(efx_fifo_bin2gray) # (.WIDTH(WADDR_WIDTH+1)                     ) wr2rd_bin2gray  (.bin_i(waddr_cntr), .gray_o(waddr_cntr_gry));
        `IP_MODULE_NAME(efx_fifo_datasync) # (.STAGE(SYNC_STAGE), .WIDTH (WADDR_WIDTH+1)) wr2rd_addr_sync (.clk_i(rclk), .d_i(waddr_cntr_gry_r), .d_o(waddr_cntr_gry_sync));
        `IP_MODULE_NAME(efx_fifo_gray2bin) # (.WIDTH(WADDR_WIDTH+1)                     ) wr2rd_gray2bin  (.gray_i(waddr_cntr_gry_sync), .bin_o(waddr_cntr_sync_g2b));        

    end
endgenerate
endmodule


////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   bin2gray.v
//       / / .'     /    
//    __/ /.'      /     Description:
//   __   \       /      Binary to Gray Encoding Convertor
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`resetall
`timescale 1ns/1ps

module `IP_MODULE_NAME(efx_fifo_bin2gray)
#(parameter WIDTH=5)
(// outputs
 output wire [WIDTH-1:0] gray_o,
 // input
 input [WIDTH-1:0] bin_i
 );

//---------------------------------------------------------------------
// Function :   bit_xor
// Description: reduction xor
function bit_xor (
  input [31:0] nex_bit,
  input [31:0] curr_bit,
  input [WIDTH-1:0] xor_in);
  begin : fn_bit_xor
    bit_xor = xor_in[nex_bit] ^ xor_in[curr_bit];
  end
endfunction

// Convert Binary to Gray, bit by bit
generate 
begin
  genvar bit_idx;
  for(bit_idx=0; bit_idx<WIDTH-1; bit_idx=bit_idx+1) begin : gBinBits
    assign gray_o[bit_idx] = bit_xor(bit_idx+1, bit_idx, bin_i);
  end
  assign   gray_o[WIDTH-1] = bin_i[WIDTH-1];
end
endgenerate

endmodule 

////////////////////////////////////////////////////////////////////////////////
// Copyright (C) 2013-2020 Efinix Inc. All rights reserved.              
//
// This   document  contains  proprietary information  which   is        
// protected by  copyright. All rights  are reserved.  This notice       
// refers to original work by Efinix, Inc. which may be derivitive       
// of other work distributed under license of the authors.  In the       
// case of derivative work, nothing in this notice overrides the         
// original author's license agreement.  Where applicable, the           
// original license agreement is included in it's original               
// unmodified form immediately below this header.                        
//
// WARRANTY DISCLAIMER.                                                  
//     THE  DESIGN, CODE, OR INFORMATION ARE PROVIDED “AS IS” AND        
//     EFINIX MAKES NO WARRANTIES, EXPRESS OR IMPLIED WITH               
//     RESPECT THERETO, AND EXPRESSLY DISCLAIMS ANY IMPLIED WARRANTIES,  
//     INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF          
//     MERCHANTABILITY, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR    
//     PURPOSE.  SOME STATES DO NOT ALLOW EXCLUSIONS OF AN IMPLIED       
//     WARRANTY, SO THIS DISCLAIMER MAY NOT APPLY TO LICENSEE.           
//
// LIMITATION OF LIABILITY.                                              
//     NOTWITHSTANDING ANYTHING TO THE CONTRARY, EXCEPT FOR BODILY       
//     INJURY, EFINIX SHALL NOT BE LIABLE WITH RESPECT TO ANY SUBJECT    
//     MATTER OF THIS AGREEMENT UNDER TORT, CONTRACT, STRICT LIABILITY   
//     OR ANY OTHER LEGAL OR EQUITABLE THEORY (I) FOR ANY INDIRECT,      
//     SPECIAL, INCIDENTAL, EXEMPLARY OR CONSEQUENTIAL DAMAGES OF ANY    
//     CHARACTER INCLUDING, WITHOUT LIMITATION, DAMAGES FOR LOSS OF      
//     GOODWILL, DATA OR PROFIT, WORK STOPPAGE, OR COMPUTER FAILURE OR   
//     MALFUNCTION, OR IN ANY EVENT (II) FOR ANY AMOUNT IN EXCESS, IN    
//     THE AGGREGATE, OF THE FEE PAID BY LICENSEE TO EFINIX HEREUNDER    
//     (OR, IF THE FEE HAS BEEN WAIVED, $100), EVEN IF EFINIX SHALL HAVE 
//     BEEN INFORMED OF THE POSSIBILITY OF SUCH DAMAGES.  SOME STATES DO 
//     NOT ALLOW THE EXCLUSION OR LIMITATION OF INCIDENTAL OR            
//     CONSEQUENTIAL DAMAGES, SO THIS LIMITATION AND EXCLUSION MAY NOT   
//     APPLY TO LICENSEE.
//
////////////////////////////////////////////////////////////////////////////////


`timescale 1 ns / 1 ns
module mii_if_3c48db7e8f7a4061b4268f003b844934
(
//Globle Signals
input                           tx_mac_aclk,
output  reg                     tx_mac_aclk_en,
input                           tx_reset,
output  wire                    rx_mac_aclk,
output  reg                     rx_mac_aclk_en,
input                           rx_reset,
//Configuration Signals
input           [2:0]           eth_speed,
//GMII Interface
output  reg     [7:0]           gm_rx_d,
output  reg                     gm_rx_dv,
output  reg                     gm_rx_err,
input           [7:0]           gm_tx_d,
input                           gm_tx_en,
input                           gm_tx_err,
//MII Interface
input                           mii_txc,
output  reg     [3:0]           mii_txd,
output  reg                     mii_tx_dv,
output  reg                     mii_tx_err,

input                           mii_rxc,
input           [3:0]           mii_rxd,
input                           mii_rx_dv,
input                           mii_rx_err

//Status and  Error Signals
);
// Parameter Define 
//localparam                      SPEED_100M_DIV = (TX_REFCLK == 125) ? 10 : 2;
//localparam                      SPEED_10M_DIV  = SPEED_100M_DIV*10;
//localparam                      SPEED_CLK_DIV = (TX_REFCLK == 125) ? SPEED_100M_DIV/2 + 1 : 0 ;
// Register Define 
reg     [6:0]                   aclk_en_cnt;
reg     [3:0]                   txd;
reg                             tx_en;
reg                             tx_er;
reg                             rx_dv_pre;
reg                             rx_dv_dl1;
reg     [3:0]                   rxd_pre;
reg     [3:0]                   rxd_dl1;
reg                             rx_odd_data_ptr;
reg     [3:0]                   rxd;
reg                             rx_dv;
reg                             rx_er;
reg     [3:0]                   gm_tx_d_h;
reg     [7:0]                   gm_tx_d_r;
reg                             gm_tx_en_r;
reg                             gm_tx_err_r;
reg				preamble_flg;
reg     [1:0]			cur_st;
reg     [1:0]			nxt_st;
reg				add_preamble;

// Wire Define

/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/

/*----------------------- Tx Region ----------------------------*/

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_mac_aclk_en <= 1'b0;
    else
        tx_mac_aclk_en <= ~tx_mac_aclk_en;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        gm_tx_d_r <= 8'h0;
    else if((gm_tx_en == 1'b1) && (tx_mac_aclk_en == 1'b1))
        gm_tx_d_r <= gm_tx_d;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        gm_tx_en_r <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        gm_tx_en_r <= gm_tx_en;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        gm_tx_err_r <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        gm_tx_err_r <= gm_tx_err;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txd <= 4'h0;
    else if(gm_tx_en_r == 1'b1) 
        begin
            if(tx_mac_aclk_en == 1'b0)
                txd <= gm_tx_d_r[3:0];
            else
                txd <= gm_tx_d_r[7:4];
        end
    else;    
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_en <= 1'b0;
    else 
        tx_en <= gm_tx_en_r;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_er <= 1'b0;
    else 
        tx_er <= gm_tx_err_r;
end

always @(posedge mii_txc)
begin 
    mii_tx_dv  <= tx_en;
    mii_txd    <= txd[3:0];
    mii_tx_err <= tx_er;
end
/*----------------------- Rx Region ----------------------------*/
always @(posedge mii_rxc)
begin
   if(mii_rxd==4'hd && mii_rx_dv && !mii_rx_err && cur_st==2'b01 && preamble_flg)
   begin
      rxd   <= 4'h5;
      rx_dv <= 1'b1;
   end
   else if(add_preamble)
   begin
      rxd <= rxd_pre;
      rx_dv <= rx_dv_pre;
   end
   else
   begin
      rxd   <= mii_rxd;
      rx_dv <= mii_rx_dv;
      rx_er <= mii_rx_err;
   end
end

assign rx_mac_aclk = mii_rxc;

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
	begin
	rxd_pre <= 4'h0;
	rx_dv_pre <= 1'b0;
	end
    else if((mii_rxd==4'hd && mii_rx_dv && !mii_rx_err && cur_st==2'b01 && preamble_flg) || add_preamble)
	begin
	rxd_pre <= mii_rxd;
	rx_dv_pre <= mii_rx_dv;
	end
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
	add_preamble <= 1'b0;
    else if(mii_rxd==4'hd && mii_rx_dv && !mii_rx_err && cur_st==2'b01 && preamble_flg)
	add_preamble <= 1'b1;
     else if(!mii_rx_dv)
	add_preamble <= 1'b0;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_mac_aclk_en <= 1'b0;
    else
        rx_mac_aclk_en <= ~rx_mac_aclk_en;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
	begin
		cur_st <= 2'b00;
	end
     else
	begin
		cur_st <= nxt_st;
	end
end

always @*
begin
case(cur_st)
2'b00: begin
	if(mii_rxd==4'h5 && mii_rx_dv && !mii_rx_err)	
	nxt_st <= 2'b01;
	else
	nxt_st <= 2'b00;
       end
2'b01: begin
	if(mii_rxd==4'hd && mii_rx_dv && !mii_rx_err)
	nxt_st <= 2'b10;
	else if (mii_rxd==4'h5 && mii_rx_dv && !mii_rx_err)
	nxt_st <= 2'b01;
	else 
	nxt_st <= 2'b00;
	end
2'b10: begin
	if(mii_rx_dv) 
	nxt_st <= 2'b10;
	else
	nxt_st <= 2'b00;
	end
default: nxt_st <= 2'b00;
endcase
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        begin
            preamble_flg <= 1'b0;
	end
    else if(mii_rxd==4'h5 && mii_rx_dv && !mii_rx_err && cur_st==2'b01)
	begin
	    preamble_flg <= ~preamble_flg;
	end
    else begin
	    preamble_flg <= 1'b0;
	end
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        begin
            rx_dv_dl1 <= 1'b0;
            rxd_dl1 <= 4'h0;
        end
    else
        begin
            rx_dv_dl1 <= rx_dv;
            rxd_dl1 <= rxd;
        end
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_dv <= 1'b0;
    else
        gm_rx_dv <= rx_dv_dl1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_odd_data_ptr <= 1'b0;
    else if(rx_dv == 1'b0)
        rx_odd_data_ptr <= 1'b0;
    else
        rx_odd_data_ptr <= ~rx_odd_data_ptr;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_d <= 8'h0;
    else if((rx_dv == 1'b1) && (rx_odd_data_ptr == 1'b1))
        gm_rx_d <= {rxd[3:0],rxd_dl1[3:0]};
    else;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_err <= 1'b0;
    else
        begin
            if(rx_er == 1'b1)
                gm_rx_err <= 1'b1;
            else if(rx_mac_aclk_en == 1'b1)
                gm_rx_err <= 1'b0;
        end
end


endmodule



/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   
//       / / .'     /    
//    __/ /.'      /     
//   __   \       /      
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`timescale 1 ns / 1 ns
module rgmii_if_3c48db7e8f7a4061b4268f003b844934#(
    parameter                       RGMII_SYNC_EN = 1
)
(
//Globle Signals
input                           tx_mac_aclk,
output  reg                     tx_mac_aclk_en,
input                           tx_reset,
output  wire                    rx_mac_aclk,
output  reg                     rx_mac_aclk_en,
input                           rx_reset,
//Configuration Signals
input           [2:0]           eth_speed,
input                           rgmii_rxc_edge,//0:DDIO Rising Edge; 1:DDIO Falling Edge; 
input                           rgmii_txc_dly,//0:rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay disable; 1:rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay enable;
//GMII Interface
output  reg     [7:0]           gm_rx_d,
output  reg                     gm_rx_dv,
output  reg                     gm_rx_err,
input           [7:0]           gm_tx_d,
input                           gm_tx_en,
input                           gm_tx_err,
//RGMII Interface
output  wire    [3:0]           rgmii_txd_HI,
output  wire    [3:0]           rgmii_txd_LO,
output  wire                    rgmii_tx_ctl_HI,
output  wire                    rgmii_tx_ctl_LO,
output  wire                    rgmii_txc_HI,//if rgmii_txc_dly set 0, used clk_125m clock. if rgmii_txc_dly set 1, used clk_125m_90deg clock.
output  wire                    rgmii_txc_LO,
input           [3:0]           rgmii_rxd_HI,
input           [3:0]           rgmii_rxd_LO,
input                           rgmii_rx_ctl_HI,
input                           rgmii_rx_ctl_LO,
input                           rgmii_rxc
//Status and  Error Signals
);

// Parameter Define 

// Register Define 
reg     [6:0]                   aclk_en_cnt;
reg     [7:0]                   txd;
reg                             tx_en;
reg                             tx_er;
reg     [1:0]                   txc;
reg                             rx_dv_dl1;
reg     [7:0]                   rxd_dl1;
reg                             rx_odd_data_ptr;

// Wire Define
wire                            rx_dv;
wire    [7:0]                   rxd;
wire                            rx_er;

/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/

/*----------------------- Tx Region ----------------------------*/
always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        aclk_en_cnt <= 7'd0;
    else if((eth_speed == 3'h4) ||
            ((eth_speed == 3'h2) && (aclk_en_cnt == 7'd9)) ||
            ((eth_speed == 3'h1) && (aclk_en_cnt == 7'd99)))
        aclk_en_cnt <= 7'd0;
    else
        aclk_en_cnt <= aclk_en_cnt + 1'b1;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_mac_aclk_en <= 1'b0;
    else if(aclk_en_cnt == 7'd0)
        tx_mac_aclk_en <= 1'b1;
    else
        tx_mac_aclk_en <= 1'b0;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txd[7:4] <= 4'h0;
    else if((gm_tx_en == 1'b1) && (tx_mac_aclk_en == 1'b1))
        txd[7:4] <= gm_tx_d[7:4];
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txd[3:0] <= 4'h0;
    else if((gm_tx_en == 1'b1) && (tx_mac_aclk_en == 1'b1))
        txd[3:0] <= gm_tx_d[3:0];
    else if(((eth_speed == 3'h2) && (aclk_en_cnt == 7'd6)) ||
            ((eth_speed == 3'h1) && (aclk_en_cnt == 7'd51)))
        txd[3:0] <= txd[7:4];
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_en <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        tx_en <= gm_tx_en;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_er <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        tx_er <= gm_tx_err;
end
/*
always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txc <= 2'b0;
    else
        case(eth_speed)
        3'h4 :
            txc <= 2'b01;
        3'h2 :
            case(rgmii_txc_dly)
            1'b0 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay disable.
                if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd5))
                    txc <= 2'b11;
                else if((aclk_en_cnt == 7'd3) || (aclk_en_cnt == 7'd8))
                    txc <= 2'b00;
            1'b1 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay enable.
                if((aclk_en_cnt == 7'd2) || (aclk_en_cnt == 7'd7))
                    txc <= 2'b11;
                else if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd5))
                    txc <= 2'b00;
            endcase
        3'h1 :
            case(rgmii_txc_dly)
            1'b0 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay disable.
                if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd50))
                    txc <= 2'b11;
                else if((aclk_en_cnt == 7'd25) || (aclk_en_cnt == 7'd75))
                    txc <= 2'b00;
            1'b1 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay enable.
                if((aclk_en_cnt == 7'd13) || (aclk_en_cnt == 7'd63))
                    txc <= 2'b11;
                else if((aclk_en_cnt == 7'd38) || (aclk_en_cnt == 7'd88))
                    txc <= 2'b00;
            endcase
        default :
            txc <= 2'b0;
        endcase
end

*/
reg [1:0]    txc_100m_r;
reg [1:0]    txc_10m_r;

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txc_100m_r <= 2'b0;
    else
        case(rgmii_txc_dly)
        1'b0 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay disable.
            if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd5))
                txc_100m_r <= 2'b11;
            else if((aclk_en_cnt == 7'd3) || (aclk_en_cnt == 7'd8))
                txc_100m_r <= 2'b00;
        1'b1 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay enable.
            if((aclk_en_cnt == 7'd2) || (aclk_en_cnt == 7'd7))
                txc_100m_r <= 2'b11;
            else if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd5))
                txc_100m_r <= 2'b00;
        endcase
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txc_10m_r <= 2'b0;
    else
        case(rgmii_txc_dly)
        1'b0 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay disable.
            if((aclk_en_cnt == 7'd0) || (aclk_en_cnt == 7'd50))
                txc_10m_r <= 2'b11;
            else if((aclk_en_cnt == 7'd25) || (aclk_en_cnt == 7'd75))
                txc_10m_r <= 2'b00;
        1'b1 ://rgmii_3c48db7e8f7a4061b4268f003b844934 tx clock delay enable.
            if((aclk_en_cnt == 7'd13) || (aclk_en_cnt == 7'd63))
                txc_10m_r <= 2'b11;
            else if((aclk_en_cnt == 7'd38) || (aclk_en_cnt == 7'd88))
                txc_10m_r <= 2'b00;
        endcase
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txc <= 2'b0;
    else
        case(eth_speed)
            3'h4 :
                txc <= 2'b01;
            3'h2 :
                txc <= txc_100m_r;
            3'h1 :
                txc <= txc_10m_r;
            default :
                txc <= 2'b0;
        endcase
end

/*----------------------- Rx Region ----------------------------*/
assign rx_mac_aclk = rgmii_rxc;

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_mac_aclk_en <= 1'b0;
    else if(eth_speed[2] == 1'b1)
        rx_mac_aclk_en <= 1'b1;
    else
        rx_mac_aclk_en <= ~rx_mac_aclk_en;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        begin
            rx_dv_dl1 <= 1'b0;
            rxd_dl1 <= 8'h0;
        end
    else
        begin
            rx_dv_dl1 <= rx_dv;
            rxd_dl1 <= rxd;
        end
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_dv <= 1'b0;
    else
        gm_rx_dv <= rx_dv_dl1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_odd_data_ptr <= 1'b0;
    else if(rx_dv == 1'b0)
        rx_odd_data_ptr <= 1'b0;
    else
        rx_odd_data_ptr <= ~rx_odd_data_ptr;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_d <= 8'h0;
    else
        begin
            if((eth_speed[2] == 1'b1) && (rx_dv_dl1 == 1'b1))
                gm_rx_d <= rxd_dl1;
            else if((rx_dv == 1'b1) && (rx_odd_data_ptr == 1'b1))
                gm_rx_d <= {rxd[3:0],rxd_dl1[3:0]};
        end
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_err <= 1'b0;
    else
        begin
            if(rx_er == 1'b1)
                gm_rx_err <= 1'b1;
            else if(rx_mac_aclk_en == 1'b1)
                gm_rx_err <= 1'b0;
        end
end

/*----------------------- PHY Interface ----------------------------*/
rgmii_3c48db7e8f7a4061b4268f003b844934 #(
    .RGMII_SYNC_EN                      (RGMII_SYNC_EN                      )
)
u_rgmii
(
//Globle Signals
    .tx_mac_aclk                        (tx_mac_aclk                        ),
//Configuration Signals
    .eth_speed                          (eth_speed                          ),
    .rgmii_rxc_edge                     (rgmii_rxc_edge                     ),
//Phy Interface
    .txd                                (txd                                ),
    .tx_en                              (tx_en                              ),
    .tx_er                              (tx_er                              ),
    .txc                                (txc                                ),
    .rxd                                (rxd                                ),
    .rx_dv                              (rx_dv                              ),
    .rx_er                              (rx_er                              ),
//RGMII Interface
    .rgmii_txd_HI                       (rgmii_txd_HI                       ),
    .rgmii_txd_LO                       (rgmii_txd_LO                       ),
    .rgmii_tx_ctl_HI                    (rgmii_tx_ctl_HI                    ),
    .rgmii_tx_ctl_LO                    (rgmii_tx_ctl_LO                    ),
    .rgmii_txc_HI                       (rgmii_txc_HI                       ),
    .rgmii_txc_LO                       (rgmii_txc_LO                       ),
    .rgmii_rxd_HI                       (rgmii_rxd_HI                       ),
    .rgmii_rxd_LO                       (rgmii_rxd_LO                       ),
    .rgmii_rx_ctl_HI                    (rgmii_rx_ctl_HI                    ),
    .rgmii_rx_ctl_LO                    (rgmii_rx_ctl_LO                    ),
    .rgmii_rxc                          (rgmii_rxc                          )
);

endmodule


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   
//       / / .'     /    
//    __/ /.'      /     
//   __   \       /      
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************
`timescale 1 ns / 1 ns
module rgmii_sync_3c48db7e8f7a4061b4268f003b844934
(
//Globle Signals
input                           rgmii_rxc,
input           [2:0]           eth_speed,
//RGMII Rx Interface Input
input           [3:0]           rgmii_rxd_HI_i,
input           [3:0]           rgmii_rxd_LO_i,
input                           rgmii_rx_ctl_HI_i,
input                           rgmii_rx_ctl_LO_i,
//RGMII Rx Interface Output
output  reg     [3:0]           rgmii_rxd_HI_o,
output  reg     [3:0]           rgmii_rxd_LO_o,
output  reg                     rgmii_rx_ctl_HI_o,
output  reg                     rgmii_rx_ctl_LO_o
);


// Parameter Define 
parameter State_idle     = 2'd0;
parameter State_preamble = 2'd1;
parameter State_data_dl1 = 2'd2;
parameter State_data_dl2 = 2'd3;


// Register Define 
reg     [1:0]                   cur_state;
reg     [1:0]                   next_state;
reg                             preamble_odd;
reg     [7:0]                   rx_d_dl1;
reg                             rx_dv_dl1;
reg     [7:0]                   rx_d_dl2;
reg                             rx_dv_dl2;

// Wire Define

/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/

always @(posedge rgmii_rxc)
begin
    rx_d_dl1[7:4] <= rgmii_rxd_HI_i;
    rx_d_dl1[3:0] <= rgmii_rxd_LO_i;
    rx_dv_dl1 <= rgmii_rx_ctl_HI_i;
    rx_d_dl2 <= rx_d_dl1;
    rx_dv_dl2 <= rx_dv_dl1;
end

/*----------------------- FSM Region ----------------------------*/
always @(posedge rgmii_rxc)
begin
	cur_state <= next_state;
end

always @(*)
begin
	case(cur_state)
    State_idle :
        if((rx_dv_dl1 == 1'b1) && (rx_d_dl1[3:0] == 4'h5))
            next_state = State_preamble;
        else
            next_state = State_idle;

    State_preamble : 
        if(rx_dv_dl1 == 1'b0)
            next_state = State_idle;
        else if((rx_d_dl1[3:0] == 4'hd) && (preamble_odd == 1'b0))
            next_state = State_data_dl1;
        else if((rx_d_dl1[3:0] == 4'hd) && (preamble_odd == 1'b1))
            next_state = State_data_dl2;
        else if(rx_d_dl1[3:0] != 4'h5)
            next_state = State_idle;
        else
            next_state = State_preamble;
        
    State_data_dl1 :
        if(rx_dv_dl1 == 1'b0)
            next_state = State_idle;
        else
            next_state = State_data_dl1;

    State_data_dl2 :
        if(rx_dv_dl2 == 1'b0)
            next_state = State_idle;
        else
            next_state = State_data_dl2;

    default :
        next_state = State_idle;
    endcase
end

always @(posedge rgmii_rxc)
begin
    if(cur_state == State_preamble)
        preamble_odd <= ~preamble_odd;
    else
        preamble_odd <= 1'b0;
end

/*----------------------- Sync Output Region ----------------------------*/

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)
        rgmii_rxd_LO_o <= rgmii_rxd_LO_i;
    else if((cur_state == State_preamble) && (rx_d_dl1[3:0] == 4'hd) && (preamble_odd == 1'b1))
        rgmii_rxd_LO_o <= 4'h5;
    else if(cur_state == State_data_dl2)
        rgmii_rxd_LO_o <= rx_d_dl2[3:0];
    else
        rgmii_rxd_LO_o <= rx_d_dl1[3:0];
end

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)
        rgmii_rxd_HI_o <= rgmii_rxd_HI_i;
    else
        rgmii_rxd_HI_o <= 4'h0;
end

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)
        rgmii_rx_ctl_HI_o <= rgmii_rx_ctl_HI_i;
    else if((cur_state == State_preamble) && (rx_d_dl1[3:0] == 4'hd) && (preamble_odd == 1'b1))
        rgmii_rx_ctl_HI_o <= 1'b1;
    else if(cur_state == State_data_dl2)
        rgmii_rx_ctl_HI_o <= rx_dv_dl2;
    else
        rgmii_rx_ctl_HI_o <= rx_dv_dl1;
end

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)
        rgmii_rx_ctl_LO_o <= rgmii_rx_ctl_LO_i;
    else if((cur_state == State_preamble) && (rx_d_dl1[3:0] == 4'hd) && (preamble_odd == 1'b1))
        rgmii_rx_ctl_LO_o <= 1'b1;
    else if(cur_state == State_data_dl2)
        rgmii_rx_ctl_LO_o <= rx_dv_dl2;
    else
        rgmii_rx_ctl_LO_o <= rx_dv_dl1;
end

endmodule


/////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   
//       / / .'     /    
//    __/ /.'      /     
//   __   \       /      
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// *******************************
// Revisions:
// 1.0 Initial rev
//
// *******************************

`timescale 1 ns / 1 ns
module rgmii_3c48db7e8f7a4061b4268f003b844934 #(
    parameter                       RGMII_SYNC_EN = 1
)
(
//Globle Signals
input                           tx_mac_aclk,
//Configuration Signals
input           [2:0]           eth_speed,
input                           rgmii_rxc_edge,//0:DDIO Rising Edge; 1:DDIO Falling Edge; 
//Phy Interface
input           [7:0]           txd,
input                           tx_en,
input                           tx_er,
input           [1:0]           txc,//if rgmii_txc_dly set 0, used clk_125m clock. if rgmii_txc_dly set 1, used clk_125m_90deg clock.
output  reg     [7:0]           rxd,
output  reg                     rx_dv,
output  reg                     rx_er,
//RGMII Interface
output  reg     [3:0]           rgmii_txd_HI,
output  reg     [3:0]           rgmii_txd_LO,
output  reg                     rgmii_tx_ctl_HI,
output  reg                     rgmii_tx_ctl_LO,
output  reg                     rgmii_txc_HI,
output  reg                     rgmii_txc_LO,
input           [3:0]           rgmii_rxd_HI,
input           [3:0]           rgmii_rxd_LO,
input                           rgmii_rx_ctl_HI,
input                           rgmii_rx_ctl_LO,
input                           rgmii_rxc
//Status and  Error Signals
);
// Parameter Define 

// Register Define 
reg     [3:0]                   rgmii_rxd_HI_d1;
reg                             rgmii_rx_ctl_HI_d1;
reg     [3:0]                   rgmii_txd_HI_r;
reg     [3:0]                   rgmii_txd_LO_r;
reg                             rgmii_tx_ctl_HI_r;
reg                             rgmii_tx_ctl_LO_r;
reg                             rgmii_txc_HI_r;
reg                             rgmii_txc_LO_r;
// Wire Define
wire                            tx_en_to_ddr;
wire                            rgmii_tx_ctl_int;
wire    [3:0]                   txd_falling;
/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/

/*----------------------- RGMII Tx Region ----------------------------*/
assign tx_en_to_ddr = (eth_speed[2] == 1'b1) ? tx_en : tx_en && (!tx_er);
assign rgmii_tx_ctl_int = tx_en ^ tx_er;

assign txd_falling = (eth_speed[2] == 1'b1) ? txd[7:4] : txd[3:0];

always @(posedge tx_mac_aclk)
begin
    rgmii_txc_HI_r    <= txc[0];
    rgmii_txc_LO_r    <= txc[1];     
    rgmii_tx_ctl_HI_r <= tx_en_to_ddr;
    rgmii_tx_ctl_LO_r <= rgmii_tx_ctl_int;
    rgmii_txd_HI_r    <= txd[3:0];
    rgmii_txd_LO_r    <= txd_falling;
end

always @(posedge tx_mac_aclk)
begin
    rgmii_txc_HI    <= rgmii_txc_HI_r   ;
    rgmii_txc_LO    <= rgmii_txc_LO_r   ;
    rgmii_tx_ctl_HI <= rgmii_tx_ctl_HI_r;
    rgmii_tx_ctl_LO <= rgmii_tx_ctl_LO_r;
    rgmii_txd_HI    <= rgmii_txd_HI_r   ;
    rgmii_txd_LO    <= rgmii_txd_LO_r   ;
end

/*----------------------- RGMII Rx Region ----------------------------*/
//rgmii_rxd & rgmii_rx_ctl
always @(posedge rgmii_rxc)
begin
	rgmii_rxd_HI_d1 <= rgmii_rxd_HI;
	rgmii_rx_ctl_HI_d1 <= rgmii_rx_ctl_HI;
end

generate
if(RGMII_SYNC_EN == 0)
begin

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)//1000M
        begin
            if(rgmii_rxc_edge == 1'b0)//0:DDIO Rising Edge
                begin
	                rxd[7:4] <= rgmii_rxd_LO;
	                rxd[3:0] <= rgmii_rxd_HI_d1;
                    rx_dv <= rgmii_rx_ctl_HI_d1;
                    rx_er <= rgmii_rx_ctl_HI_d1^rgmii_rx_ctl_LO;
                end
            else//1:DDIO Falling Edge
                begin
        	        rxd[7:4] <= rgmii_rxd_HI;
        	        rxd[3:0] <= rgmii_rxd_LO;
                    rx_dv <= rgmii_rx_ctl_LO;
                    rx_er <= rgmii_rx_ctl_LO^rgmii_rx_ctl_HI;
                end
        end
    else//100M or 10M
        begin
        	rxd[7:4] <= 4'b0;
        	rxd[3:0] <= rgmii_rxd_LO;
            rx_dv <= rgmii_rx_ctl_LO;
            rx_er <= rgmii_rx_ctl_LO^rgmii_rx_ctl_HI_d1;
        end
end

end
else
begin

reg     [3:0]                   rgmii_rxd_HI_i;
reg     [3:0]                   rgmii_rxd_LO_i;
reg                             rgmii_rx_ctl_HI_i;
reg                             rgmii_rx_ctl_LO_i;
wire    [3:0]                   rgmii_rxd_HI_sync;
wire    [3:0]                   rgmii_rxd_LO_sync;
wire                            rgmii_rx_ctl_HI_sync;
wire                            rgmii_rx_ctl_LO_sync;

always @(posedge rgmii_rxc)
begin
    if(eth_speed[2] == 1'b1)//1000M
        begin
            if(rgmii_rxc_edge == 1'b0)//0:DDIO Rising Edge
                begin
	                rgmii_rxd_HI_i <= rgmii_rxd_LO;
	                rgmii_rxd_LO_i <= rgmii_rxd_HI_d1;
                    rgmii_rx_ctl_HI_i <= rgmii_rx_ctl_HI_d1;
                    rgmii_rx_ctl_LO_i <= rgmii_rx_ctl_LO;
                end
            else//1:DDIO Falling Edge
                begin
	                rgmii_rxd_HI_i <= rgmii_rxd_HI;
	                rgmii_rxd_LO_i <= rgmii_rxd_LO;
                    rgmii_rx_ctl_HI_i <= rgmii_rx_ctl_HI;
                    rgmii_rx_ctl_LO_i <= rgmii_rx_ctl_LO;
                end
        end        
    else//100M or 10M
        begin
            rgmii_rxd_HI_i <= rgmii_rxd_HI_d1;
	        rgmii_rxd_LO_i <= rgmii_rxd_LO;
            rgmii_rx_ctl_HI_i <= rgmii_rx_ctl_LO;
            rgmii_rx_ctl_LO_i <= rgmii_rx_ctl_HI_d1;
        end
end

always @(posedge rgmii_rxc)
begin
	rxd[7:4] <= rgmii_rxd_HI_sync;
	rxd[3:0] <= rgmii_rxd_LO_sync;
    rx_dv <= rgmii_rx_ctl_HI_sync;
    rx_er <= rgmii_rx_ctl_HI_sync^rgmii_rx_ctl_LO_sync;
end

/*----------------------- RGMII Rx Sync Module -----------------------*/
rgmii_sync_3c48db7e8f7a4061b4268f003b844934 u_rgmii_sync
(
//Globle Signals
    .rgmii_rxc                  (rgmii_rxc                  ),
    .eth_speed                  (eth_speed                  ),
//RGMII Rx Interface Input
    .rgmii_rxd_HI_i             (rgmii_rxd_HI_i             ),
    .rgmii_rxd_LO_i             (rgmii_rxd_LO_i             ),
    .rgmii_rx_ctl_HI_i          (rgmii_rx_ctl_HI_i          ),
    .rgmii_rx_ctl_LO_i          (rgmii_rx_ctl_LO_i          ),
//RGMII Rx Interface Output
    .rgmii_rxd_HI_o             (rgmii_rxd_HI_sync          ),
    .rgmii_rxd_LO_o             (rgmii_rxd_LO_sync          ),
    .rgmii_rx_ctl_HI_o          (rgmii_rx_ctl_HI_sync       ),
    .rgmii_rx_ctl_LO_o          (rgmii_rx_ctl_LO_sync       )
);

end
endgenerate


endmodule


`timescale 1 ns / 1 ns
module rmii_if_3c48db7e8f7a4061b4268f003b844934
(
//Globle Signals
input                           tx_mac_aclk,
output  reg                     tx_mac_aclk_en,
input                           tx_reset,
output  wire                    rx_mac_aclk,
output  reg                     rx_mac_aclk_en,
input                           rx_reset,
//Configuration Signals
input           [2:0]           eth_speed,
//GMII Interface
output  reg     [7:0]           gm_rx_d,
output  reg                     gm_rx_dv,
output  reg                     gm_rx_err,
input           [7:0]           gm_tx_d,
input                           gm_tx_en,
input                           gm_tx_err,
//RGMII Interface
input                           rmii_clk_ref,
output  reg     [1:0]           rmii_txd,
output  reg                     rmii_tx_en,

input           [1:0]           rmii_rxd,
input                           rmii_crs_dv,
input                           rmii_rx_err

//Status and  Error Signals
);
// Parameter Define 

// Register Define 
reg     [6:0]                   aclk_en_cnt;
reg     [6:0]                   rx_aclk_en_cnt;
reg     [1:0]                   txd;
reg                             tx_en;
reg                             tx_er;
reg                             rx_err_dl1;
reg                             rx_dv_dl1;
reg     [7:0]                   rxd_dl1;
reg     [6:0]                   rx_odd_data_ptr;
reg     [3:0]                   rxd;
reg                             rx_dv;
reg                             rx_er;
reg     [7:0]                   gm_tx_d_temp;
reg                             tx_en_temp;
reg     [6:0]                   txbit_cnt;
reg                             rx_dv_compensate;
reg                             rx_err_compensate;
reg     [7:0]                   rx_d_compensate;
reg     [6:0]                   rx_compensate_cnt;
// Wire Define

/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/

/*----------------------- Tx Region ----------------------------*/
always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        aclk_en_cnt <= 7'd0;
    else if(((eth_speed == 3'h2) && (aclk_en_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (aclk_en_cnt == 7'd39)))
        aclk_en_cnt <= 7'd0;
    else
        aclk_en_cnt <= aclk_en_cnt + 1'b1;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_mac_aclk_en <= 1'b0;
    else if(aclk_en_cnt == 7'd0)
        tx_mac_aclk_en <= 1'b1;
    else
        tx_mac_aclk_en <= 1'b0;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        gm_tx_d_temp <= 8'h0;
    else if((gm_tx_en == 1'b1) && (tx_mac_aclk_en == 1'b1))
        gm_tx_d_temp <= gm_tx_d;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_en_temp <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        tx_en_temp <= gm_tx_en;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txbit_cnt <= 7'd0;
    else if(((eth_speed == 3'h2) && (txbit_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (txbit_cnt == 7'd39)))
        txbit_cnt <= 7'd0;
    else if(tx_en_temp == 1'b1)
        txbit_cnt <= txbit_cnt + 1'b1;
    else
        txbit_cnt <= 7'd0; 
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        txd <= 2'h0;
    else if(eth_speed == 3'h2)
        begin
            case(txbit_cnt[1:0])
                2'b00: txd <= gm_tx_d_temp[1:0];
                2'b01: txd <= gm_tx_d_temp[3:2];
                2'b10: txd <= gm_tx_d_temp[5:4];
                2'b11: txd <= gm_tx_d_temp[7:6];
                default; 
            endcase 
        end 
    else if(eth_speed == 3'h1)
        begin
            case(txbit_cnt[5:0])
                6'd00: txd <= gm_tx_d_temp[1:0];
                6'd10: txd <= gm_tx_d_temp[3:2];
                6'd20: txd <= gm_tx_d_temp[5:4];
                6'd30: txd <= gm_tx_d_temp[7:6];
                default; 
            endcase 
        end
    else;    
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_en <= 1'b0;
    else 
        tx_en <= tx_en_temp;
end

always @(posedge tx_mac_aclk or posedge tx_reset)
begin
    if(tx_reset == 1'b1)
        tx_er <= 1'b0;
    else if(tx_mac_aclk_en == 1'b1)
        tx_er <= gm_tx_err;
end

always @(posedge rmii_clk_ref)
begin 
    rmii_tx_en  <= tx_en;
    rmii_txd    <= txd[1:0];
//    rmii_tx_err <= tx_er;
end

/*----------------------- Rx Region ----------------------------*/
always @(posedge rmii_clk_ref)
begin
	rxd   <= rmii_rxd;
    rx_dv <= rmii_crs_dv;
    rx_er <= rmii_rx_err;
end

assign rx_mac_aclk = rmii_clk_ref;

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_aclk_en_cnt <= 7'd0;
    else if(((eth_speed == 3'h2) && (rx_aclk_en_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (rx_aclk_en_cnt == 7'd39)))
        rx_aclk_en_cnt <= 7'd0;
    else
        rx_aclk_en_cnt <= rx_aclk_en_cnt + 1'b1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_mac_aclk_en <= 1'b0;
    else if(rx_aclk_en_cnt == 7'd0)
        rx_mac_aclk_en <= 1'b1;
    else
        rx_mac_aclk_en <= 1'b0;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_odd_data_ptr <= 7'd0;
    else if(((eth_speed == 3'h2) && (rx_odd_data_ptr == 7'd3)) ||
            ((eth_speed == 3'h1) && (rx_odd_data_ptr == 7'd39)) || (rx_dv == 1'b0))
        rx_odd_data_ptr <= 7'd0;
    else 
        rx_odd_data_ptr <= rx_odd_data_ptr + 1'b1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_dv_dl1 <= 1'b0;
    else 
        rx_dv_dl1 <= rx_dv; 
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_err_dl1 <= 1'b0;
    else 
        rx_err_dl1 <= rx_er; 
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rxd_dl1 <= 8'h0;
    else if(eth_speed == 3'h2)
        begin
            case(rx_odd_data_ptr[1:0])
                2'b00: rxd_dl1[1:0] <= rxd;
                2'b01: rxd_dl1[3:2] <= rxd;
                2'b10: rxd_dl1[5:4] <= rxd;
                2'b11: rxd_dl1[7:6] <= rxd;
                default; 
            endcase 
        end 
    else if(eth_speed == 3'h1)
        begin
            case(rx_odd_data_ptr[5:0])
                6'd00: rxd_dl1[1:0] <= rxd;
                6'd10: rxd_dl1[3:2] <= rxd;
                6'd20: rxd_dl1[5:4] <= rxd;
                6'd30: rxd_dl1[7:6] <= rxd;
                default; 
            endcase 
        end
    else;    
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_compensate_cnt <= 7'b0;
    else if(rx_dv_dl1 == 1'b1)
        rx_compensate_cnt <= 7'b0;
    else if(((eth_speed == 3'h2) && (rx_compensate_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (rx_compensate_cnt == 7'd39)))
        rx_compensate_cnt <= rx_compensate_cnt;
    else
        rx_compensate_cnt <= rx_compensate_cnt + 1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_dv_compensate <= 1'b0;
    else if(((eth_speed == 3'h2) && (rx_compensate_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (rx_compensate_cnt == 7'd39)))
        rx_dv_compensate <= 1'b0;
    else if((rx_dv_dl1 == 1'b1) && rx_odd_data_ptr == 7'd0)
        rx_dv_compensate <= 1'b1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_err_compensate <= 1'b0;
    else if(((eth_speed == 3'h2) && (rx_compensate_cnt == 7'd3)) ||
            ((eth_speed == 3'h1) && (rx_compensate_cnt == 7'd39)))
        rx_err_compensate <= 1'b0;
    else if((rx_dv_dl1 == 1'b1) && (rx_err_dl1 == 1'b1) && rx_odd_data_ptr == 7'd0)
        rx_err_compensate <= 1'b1;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        rx_d_compensate <= 8'h0;
    else if((rx_dv_dl1 == 1'b1) && rx_odd_data_ptr == 7'd0)
        rx_d_compensate <= rxd_dl1;
    else;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_dv <= 1'b0;
    else if(rx_mac_aclk_en == 1'b1)
        gm_rx_dv <= rx_dv_compensate;
end


always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_d <= 8'h0;
    else if(rx_mac_aclk_en == 1'b1)
        gm_rx_d <= rx_d_compensate;
    else;
end

always @(posedge rx_mac_aclk or posedge rx_reset)
begin
    if(rx_reset == 1'b1)
        gm_rx_err <= 1'b0;
    else if(rx_mac_aclk_en == 1'b1)
        gm_rx_err <= rx_err_compensate;
end

endmodule



//////////////////////////////////////////////////////////////////////////////
//           _____       
//          / _______    Copyright (C) 2013-2020 Efinix Inc. All rights reserved.
//         / /       \   
//        / /  ..    /   
//       / / .'     /    
//    __/ /.'      /     
//   __   \       /      
//  /_/ /\ \_____/ /     
// ____/  \_______/      
//
// ********************************
// Revisions:
// 1.0 Initial rev 
//
// *******************************

`timescale 1 ns / 1 ns
module `IP_MODULE_NAME(tsemac) #(
    parameter    VERSION = 32'h10,
    parameter    RXFIFO_EN = 1,
    parameter    RXFIFO_DTH = 2048,
    parameter    TXFIFO_EN = 1,
    parameter    TXFIFO_DTH = 2048,
    parameter    PHY_INTF_MODE = 0,  //0-rgmii_3c48db7e8f7a4061b4268f003b844934, 1-mii, 2-rmii, 3-gmii
    parameter    AXIS_DW = 8  // 8, 16, or 32
)
(
//Globle Signals
input                           mac_reset,//Globle Reset
input                           proto_reset,//Tx & Rx Reset
input                           tx_mac_aclk,//125M 
output  wire                    rx_mac_aclk,
output  wire    [2:0]           eth_speed,
//Receive AXI4-Stream Interface
input                           rx_axis_clk,
output  wire    [AXIS_DW-1:0]   rx_axis_mac_tdata,
output  wire                    rx_axis_mac_tvalid,
output  wire                    rx_axis_mac_tlast,
output  wire    [AXIS_DW/8-1:0] rx_axis_mac_tstrb,
output  wire                    rx_axis_mac_tuser,
input                           rx_axis_mac_tready,
//Transmit AXI4-Stream Interface
input                           tx_axis_clk,
input           [AXIS_DW-1:0]   tx_axis_mac_tdata,
input                           tx_axis_mac_tvalid,
input                           tx_axis_mac_tlast,
input           [AXIS_DW/8-1:0] tx_axis_mac_tstrb,
input                           tx_axis_mac_tuser,
output  wire                    tx_axis_mac_tready,
//AXI4-Lite Interface
input                           s_axi_aclk,//AXI Bus Clock.
input           [9:0]           s_axi_awaddr,//Write Address. byte address.
input                           s_axi_awvalid,//Write address valid.
output  wire                    s_axi_awready,//Write address ready.
input           [31:0]          s_axi_wdata,//Write data bus.
input                           s_axi_wvalid,//Write valid.
output  wire                    s_axi_wready,//Write ready.
output  wire    [1:0]           s_axi_bresp,//Write response.
output  wire                    s_axi_bvalid,//Write response valid.
input                           s_axi_bready,//Response ready.
input           [9:0]           s_axi_araddr,//Read address. byte address.
input                           s_axi_arvalid,//Read address valid.
output  wire                    s_axi_arready,//Read address ready.
output  wire    [1:0]           s_axi_rresp,//Read response.
output  wire    [31:0]          s_axi_rdata,//Read data.
output  wire                    s_axi_rvalid,//Read valid.
input                           s_axi_rready,//Read ready.              
//MDIO Interface
output  wire                    Mdo,//MII Management Data Output
output  wire                    MdoEn,//MII Management Data Output Enable
input                           Mdi,//MII Management Data Input
output  wire                    Mdc,//MII Management Data Clock 

//RGMII Interface
output  wire    [3:0]           rgmii_txd_HI,
output  wire    [3:0]           rgmii_txd_LO,
output  wire                    rgmii_tx_ctl_HI,
output  wire                    rgmii_tx_ctl_LO,
output  wire                    rgmii_txc_HI,
output  wire                    rgmii_txc_LO,
input           [3:0]           rgmii_rxd_HI,
input           [3:0]           rgmii_rxd_LO,
input                           rgmii_rx_ctl_HI,
input                           rgmii_rx_ctl_LO,
input                           rgmii_rxc,

//MII Interface
input                           mii_txc,
output  wire    [3:0]           mii_txd,
output  wire                    mii_tx_dv,
output  wire                    mii_tx_err,
input                           mii_rxc,
input           [3:0]           mii_rxd,
input                           mii_rx_dv,
input                           mii_rx_err,

//RMII Interface
input                           rmii_clk_ref,
output  wire    [1:0]           rmii_txd,
output  wire                    rmii_tx_en,
input           [1:0]           rmii_rxd,
input                           rmii_crs_dv,
input                           rmii_rx_err,

//GMII Interface
input                           gm_rx_c,
input           [7:0]           gm_rx_d,
input                           gm_rx_dv,
input                           gm_rx_err,
output  wire                    gm_tx_c,
output  wire    [7:0]           gm_tx_d,
output  wire                    gm_tx_en,
output  wire                    gm_tx_err
);

// Parameter Define 

// Register Define 

// Wire Define 
wire                    tx_mac_aclk_en;
wire                    rx_mac_aclk_en;
wire                    tx_mac_aclk_int;

//GMII Interface
wire    [7:0]           gm_rx_d_int;
wire                    gm_rx_dv_int;
wire                    gm_rx_err_int;
wire    [7:0]           gm_tx_d_int;
wire                    gm_tx_en_int;
wire                    gm_tx_err_int;

/*----------------------------------------------------------------------------------*\
                                 The main code
\*----------------------------------------------------------------------------------*/
generate if (PHY_INTF_MODE == 0) begin
    assign tx_mac_aclk_int = tx_mac_aclk;
end
else if (PHY_INTF_MODE == 1) begin
    assign tx_mac_aclk_int = mii_txc;
end
else if (PHY_INTF_MODE == 2) begin
    assign tx_mac_aclk_int = rmii_clk_ref;
end
else begin
    assign tx_mac_aclk_int = tx_mac_aclk;
end
endgenerate


/*----------------------- The Tri-mode Ethernet MAC core -----------------------*/
`IP_MODULE_NAME(tsemac_core) #(
    .VERSION    (10),
    .RXFIFO_EN  (RXFIFO_EN),
    .RXFIFO_DTH (RXFIFO_DTH),    
    .TXFIFO_EN  (TXFIFO_EN),
    .TXFIFO_DTH (TXFIFO_DTH),
    .AXIS_DW    (AXIS_DW) 
)
u_tse_mac
(
//Globle Signals
    .mac_reset                          (mac_reset                          ),
    .proto_reset                        (proto_reset                        ),
    .tx_mac_aclk                        (tx_mac_aclk_int                    ),
    .rx_mac_aclk                        (rx_mac_aclk                        ),
    .tx_mac_aclk_en                     (tx_mac_aclk_en                     ),
    .rx_mac_aclk_en                     (rx_mac_aclk_en                     ),
    .eth_speed                          (eth_speed                          ),
//Receive AXI4-Stream Interface 
    .rx_axis_clk                        (rx_axis_clk                        ),
    .rx_axis_mac_tdata                  (rx_axis_mac_tdata                  ),
    .rx_axis_mac_tvalid                 (rx_axis_mac_tvalid                 ),
    .rx_axis_mac_tlast                  (rx_axis_mac_tlast                  ),
    .rx_axis_mac_tstrb                  (rx_axis_mac_tstrb                  ),    
    .rx_axis_mac_tuser                  (rx_axis_mac_tuser                  ),
    .rx_axis_mac_tready                 (rx_axis_mac_tready                 ),
//Transmit AXI4-Stream Interface
    .tx_axis_clk                        (tx_axis_clk                        ),
    .tx_axis_mac_tdata                  (tx_axis_mac_tdata                  ),
    .tx_axis_mac_tvalid                 (tx_axis_mac_tvalid                 ),
    .tx_axis_mac_tlast                  (tx_axis_mac_tlast                  ),
    .tx_axis_mac_tstrb                  (tx_axis_mac_tstrb                  ),    
    .tx_axis_mac_tuser                  (tx_axis_mac_tuser                  ),
    .tx_axis_mac_tready                 (tx_axis_mac_tready                 ),
//GMII Interface
    .gm_rx_d                            (gm_rx_d_int                        ),
    .gm_rx_dv                           (gm_rx_dv_int                       ),
    .gm_rx_err                          (gm_rx_err_int                      ),
    .gm_tx_d                            (gm_tx_d_int                        ),
    .gm_tx_en                           (gm_tx_en_int                       ),
    .gm_tx_err                          (gm_tx_err_int                      ),
//AXI4-Lite Interface
    .s_axi_aclk                         (s_axi_aclk                         ),
    .s_axi_awaddr                       (s_axi_awaddr                       ),
    .s_axi_awvalid                      (s_axi_awvalid                      ),
    .s_axi_awready                      (s_axi_awready                      ),
    .s_axi_wdata                        (s_axi_wdata                        ),
    .s_axi_wvalid                       (s_axi_wvalid                       ),
    .s_axi_wready                       (s_axi_wready                       ),
    .s_axi_bresp                        (s_axi_bresp                        ),
    .s_axi_bvalid                       (s_axi_bvalid                       ),
    .s_axi_bready                       (s_axi_bready                       ),
    .s_axi_araddr                       (s_axi_araddr                       ),
    .s_axi_arvalid                      (s_axi_arvalid                      ),
    .s_axi_arready                      (s_axi_arready                      ),
    .s_axi_rresp                        (s_axi_rresp                        ),
    .s_axi_rdata                        (s_axi_rdata                        ),
    .s_axi_rvalid                       (s_axi_rvalid                       ),
    .s_axi_rready                       (s_axi_rready                       ),
//MDIO Interface
    .Mdo                                (Mdo                                ),
    .MdoEn                              (MdoEn                              ),
    .Mdi                                (Mdi                                ),
    .Mdc                                (Mdc                                )
);

/*----------------------- Physical Interface Region ----------------------------*/
generate 
if (PHY_INTF_MODE == 0) begin
    rgmii_if_3c48db7e8f7a4061b4268f003b844934 u_rgmii_if
    (
    //Globle Signals
        .tx_mac_aclk                        (tx_mac_aclk                        ),
        .tx_mac_aclk_en                     (tx_mac_aclk_en                     ),
        .tx_reset                           (mac_reset || proto_reset           ),
        .rx_mac_aclk                        (rx_mac_aclk                        ),
        .rx_mac_aclk_en                     (rx_mac_aclk_en                     ),
        .rx_reset                           (mac_reset || proto_reset           ),
    //Configuration Signals                                                     
        .eth_speed                          (eth_speed                          ),
        .rgmii_rxc_edge                     (1'b1                               ),
        .rgmii_txc_dly                      (1'b1                               ),
    //GMII Interface                                                            
        .gm_rx_d                            (gm_rx_d_int                        ),
        .gm_rx_dv                           (gm_rx_dv_int                       ),
        .gm_rx_err                          (gm_rx_err_int                      ),
        .gm_tx_d                            (gm_tx_d_int                        ),
        .gm_tx_en                           (gm_tx_en_int                       ),
        .gm_tx_err                          (gm_tx_err_int                      ),
    //RGMII Interface                                                           
        .rgmii_txd_HI                       (rgmii_txd_HI                       ),
        .rgmii_txd_LO                       (rgmii_txd_LO                       ),
        .rgmii_tx_ctl_HI                    (rgmii_tx_ctl_HI                    ),
        .rgmii_tx_ctl_LO                    (rgmii_tx_ctl_LO                    ),
        .rgmii_txc_HI                       (rgmii_txc_HI                       ),
        .rgmii_txc_LO                       (rgmii_txc_LO                       ),
        .rgmii_rxd_HI                       (rgmii_rxd_HI                       ),
        .rgmii_rxd_LO                       (rgmii_rxd_LO                       ),
        .rgmii_rx_ctl_HI                    (rgmii_rx_ctl_HI                    ),
        .rgmii_rx_ctl_LO                    (rgmii_rx_ctl_LO                    ),
        .rgmii_rxc                          (rgmii_rxc                          )
    );
end
else if (PHY_INTF_MODE == 1) begin
    mii_if_3c48db7e8f7a4061b4268f003b844934 u_mii_if
    (
    //Globle Signals
        .tx_mac_aclk                        (mii_txc                            ),
        .tx_mac_aclk_en                     (tx_mac_aclk_en                     ),
        .tx_reset                           (mac_reset || proto_reset           ),
        .rx_mac_aclk                        (rx_mac_aclk                        ),
        .rx_mac_aclk_en                     (rx_mac_aclk_en                     ),
        .rx_reset                           (mac_reset || proto_reset           ),
    //Configuration Signals                                                     
        .eth_speed                          (eth_speed                          ),
    //GMII Interface                                                            
        .gm_rx_d                            (gm_rx_d_int                        ),
        .gm_rx_dv                           (gm_rx_dv_int                       ),
        .gm_rx_err                          (gm_rx_err_int                      ),
        .gm_tx_d                            (gm_tx_d_int                        ),
        .gm_tx_en                           (gm_tx_en_int                       ),
        .gm_tx_err                          (gm_tx_err_int                      ),
    //MII Interface                                                           
        .mii_txc                            (mii_txc                       ),
        .mii_txd                            (mii_txd                       ),
        .mii_tx_dv                          (mii_tx_dv                     ),
        .mii_tx_err                         (mii_tx_err                    ),
        .mii_rxc                            (mii_rxc                       ),
        .mii_rxd                            (mii_rxd                       ),
        .mii_rx_dv                          (mii_rx_dv                     ),
        .mii_rx_err                         (mii_rx_err                    )
    );
end
else if (PHY_INTF_MODE == 2) begin
    rmii_if_3c48db7e8f7a4061b4268f003b844934 u_rmii_if
    (
    //Globle Signals
        .tx_mac_aclk                        (rmii_clk_ref                       ),
        .tx_mac_aclk_en                     (tx_mac_aclk_en                     ),
        .tx_reset                           (mac_reset || proto_reset           ),
        .rx_mac_aclk                        (rx_mac_aclk                        ),
        .rx_mac_aclk_en                     (rx_mac_aclk_en                     ),
        .rx_reset                           (mac_reset || proto_reset           ),
    //Configuration Signals                                                     
        .eth_speed                          (eth_speed                          ),
    //GMII Interface   
        .gm_rx_d                            (gm_rx_d_int                        ),
        .gm_rx_dv                           (gm_rx_dv_int                       ),
        .gm_rx_err                          (gm_rx_err_int                      ),
        .gm_tx_d                            (gm_tx_d_int                        ),
        .gm_tx_en                           (gm_tx_en_int                       ),
        .gm_tx_err                          (gm_tx_err_int                      ),
    //MII Interface                                                           
        .rmii_clk_ref                       (rmii_clk_ref                      ),
        .rmii_txd                           (rmii_txd                          ),
        .rmii_tx_en                         (rmii_tx_en                        ),
        .rmii_rxd                           (rmii_rxd                          ),
        .rmii_crs_dv                        (rmii_crs_dv                       ),
        .rmii_rx_err                        (rmii_rx_err                       )
    );
end
else if (PHY_INTF_MODE == 3) begin
    wire g_reset;
    reg rx_mac_aclk_en_int, tx_mac_aclk_en_int;
    
    assign rx_mac_aclk = gm_rx_c;
    assign g_reset = mac_reset || proto_reset;
    assign rx_mac_aclk_en = rx_mac_aclk_en_int;
    assign tx_mac_aclk_en = tx_mac_aclk_en_int;

    always @(posedge rx_mac_aclk or posedge g_reset)
    begin
        if(g_reset == 1'b1)
            rx_mac_aclk_en_int <= 1'b0;
        else
            rx_mac_aclk_en_int <= ~rx_mac_aclk_en_int;
    end
    
    always @(posedge tx_mac_aclk or posedge g_reset)
    begin
        if(g_reset == 1'b1)
            tx_mac_aclk_en_int <= 1'b0;
        else
            tx_mac_aclk_en_int <= ~tx_mac_aclk_en_int;
    end
    
    assign gm_rx_d_int   = gm_rx_d;
    assign gm_rx_dv_int  = gm_rx_dv;
    assign gm_rx_err_int = gm_rx_err;
    assign gm_tx_d       = gm_tx_d_int;
    assign gm_tx_en      = gm_tx_en_int;
    assign gm_tx_err     = gm_tx_err_int;
    assign gm_tx_c       = tx_mac_aclk;
end
endgenerate 

endmodule

`undef IP_UUID
`undef IP_NAME_CONCAT
`undef IP_MODULE_NAME
